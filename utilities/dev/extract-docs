#!/uns/bin/perl -w
# $Id$ -*- perl -*-
# extract-docs
# By Greg J. Badros -- 7-July-1998
#
# extract-docs pulls out the SCWM_PROC declarations and comments
# from a SCWM .c source file and processes them to create
# documentation
#
# Usage: extract-docs <filenames-to-extract-from>
#
# e.g.,
#
# extract-docs *.c
#
# Goal:
# Ultimately, this should output tagged sgml suitable for sgml-doc
# Right now, it just does the extraction into high-level elements w/o
# adding the logical tags
#
# Note that it does lots of important error checking, and produces error and warning
# messages that look like grep, so emacs' compile-mode (and probably grep-mode)
# can be used to find problems with the documentation using M-x compile (C-x c)
#   extract-docs *.c > /dev/null
# then M-x next-error (C-x `)
#
# TODO:
# Generate DocBook output!
#
# BUGS:
# This should probably be written in guile-scheme instead of perl
#

use strict;
use constant TRUE => (1==1);
use constant FALSE => (1==0);

my $header = "";
#my $fDebug = TRUE;
my $fDebug = FALSE;

while (<>) {
  close(ARGV) if (eof);
  if (m/^SCWM_PROC/) {
    $header = $_;
    while (($_ = <>) !~ m/^\s*{/) {
      $header .= $_;
    }
    $header .= $_;
    ProcessHeader($header);
    $header = "";
  }
}


sub ProcessHeader( $ ) {
  my ($header) = @_;
  my ($cprimname, $primname, $req, $opt, $var, $argslist) =
    $header =~ m%^SCWM_PROC\s*\(\s*([^, \t]*),\s*\"([^\"]*)\"\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*\(([^)]*)\)%;
  if (!defined($cprimname)) {
    print STDERR "$ARGV:$.:****ERROR:could not parse argument list\n";
    return FALSE;
  }
  my ($comment) = $header =~ m%/\*\*\s*(.*)\s*\*/%s;
  my ($fname_define) = $header =~ m%^\s*\#\s*define\s+FUNC_NAME\s+(.*?)\s*$%m;

{ # cperl-mode gets confused at above regexp, so provide scope to help it out
  my $clean_argslist = $argslist;
  my $cremovals = ($clean_argslist =~ s/\bSCM\b//g);
  $clean_argslist =~ s/\n/ /g;
  $clean_argslist =~ s/[ \t]+//g;
  $clean_argslist =~ s/_/-/g;
  $clean_argslist =~ s/-[pP]\b/?/g;
  $clean_argslist =~ s/-[xX]\b/!/g;
  my @args = split(/,/, $clean_argslist);

  # now convert the c function name into the expected (preferred) primitive name:
  my $expected_primname = $cprimname;
  $expected_primname =~ s/_/-/g;
  $expected_primname =~ s/-[pP]\b/?/g;
  $expected_primname =~ s/-[xX]\b/!/g;
  # alternative possibility (ignoring chance of multiple to's in string)
  my $expected_primname2 = $expected_primname;
  $expected_primname2 =~ s/-to-/->/g;

  
  # now create a hash of the names for testing words in the comment
  # whether they are referring to formal parameters
  my %argnames = map { uc($_) => 1} @args;

  if ($primname ne $expected_primname && $primname ne $expected_primname2) {
    print STDERR "$ARGV:$.:****$cprimname: expected scheme primitive named \`$expected_primname\'\n";
  }

  if ($cremovals != scalar(@args) ) {
    print STDERR "$ARGV:$.:****$cprimname: types inconsistency (all args should be type SCM)\n";
  }

  if (($req + $opt + $var) != scalar(@args)  ) {
    print STDERR "$ARGV:$.:****$cprimname: argument inconsistency -- check #s of arguments\n";
  }

  if ($var != 0 && $var != 1) {
    print STDERR "$ARGV:$.:****$cprimname: number of variable arguments == $var -- why?\n";
  }

  if (!defined($comment) || $comment eq "") {
    print STDERR "$ARGV:$.:****$cprimname: comment missing\n";
    $comment = "";
  }

  if (!defined($fname_define)) {
    print STDERR "$ARGV:$.:****$cprimname: \`#define FUNC_NAME s_$cprimname\' is missing\n";
  } elsif ($fname_define ne "s_".$cprimname) {
    print STDERR "$ARGV:$.:****$cprimname: \`#define FUNC_NAME s_$cprimname\' does not match function name \`$fname_define\'\n";
  }

  my @required_args = @args[0..($req-1)];
  my @optional_args = @args[$req..($req + $opt - 1)];
  my @var_args = @args[($req+$opt)..($req+$opt+$var-1)];

  my $arg_listing = "";
  if ($#args >= 0) {
    $arg_listing .= "@required_args";
    if ($#optional_args >= 0) {
      $arg_listing .= " #&optional @optional_args";
    }
    if ($#var_args >= 0) {
      $arg_listing .= " . @var_args";
    }
  }

  my $usage = sprintf "($primname%s$arg_listing)", ($arg_listing ne ""? " ":"");

  my %upcase_words = ();

  # check to make sure all all-uppercase words in the comment
  # refer to formals
  foreach my $word (split /[^\w-?!\"]+/, $comment) {
    if ($word =~ /^[A-Z][-A-Z0-9_+]+$/) {
      if (!defined($argnames{$word})) {
	print STDERR "$ARGV:$.:****$cprimname: all-uppercase word \`$word\' does not match an argument\n";
      }
    }
  }

  # check to make sure all formals are referred to in the comment
  # warning is #**** since these are less severe problems and one
  # may choose to filter them
  foreach my $formal (keys %argnames) {
    if ($comment !~ /\Q$formal\E/) {
      print STDERR "$ARGV:$.:\#***$cprimname: formal $formal not mentioned in comment\n";
    }
  }


  if ($fDebug) {
    print <<EOC
scheme-primitive-name:	$primname
C-primitive-name:	$cprimname
arg kinds:		$req, $opt, $var
args:			@args
arg listing:		$arg_listing
fname define:           $fname_define
EOC
;
  }
  print <<EOC
usage:			$usage
comment:		$comment
EOC
  ;
  print "\n";
} # end helper scope
  return TRUE;
}
