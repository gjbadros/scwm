#!/uns/bin/perl -w
# $Id$ -*- perl -*-
# extract-docs
# By Greg J. Badros -- 7-July-1998
#
# extract-docs pulls out the SCWM_PROC declarations and comments
# from a SCWM .c source file and processes them to create
# documentation
#
# Usage: extract-docs <filenames-to-extract-from>
#
# e.g.,
#
# extract-docs *.c
#
# Goal:
# Ultimately, this should output tagged sgml suitable for sgml-doc
# Right now, it just does the extraction into high-level elements w/o
# adding the logical tags
#
# Note that it does some error checking, and produces error and warning
# messages that look like grep, so emacs' compile-mode (and probably grep-mode)
# can be used to find problems with the documentation using M-x compile (C-x c)
#   extract-docs *.c
# then M-x next-error (C-x `)
#
# TODO:
#  * ensure that #define FUNC_NAME, #undef FUNC_NAME appear as appropriate (when used pervasively)
#  * better abstractions for argument checking
#
# BUGS:
# This should probably be written in guile-scheme instead of perl
#

use strict;
use constant TRUE => (1==1);
use constant FALSE => (1==0);

my $header = "";
#my $fDebug = FALSE;
my $fDebug = FALSE;

while (<>) {
  close(ARGV) if (eof);
  if (m/^SCWM_PROC/) {
    $header = $_;
    while (($_ = <>) !~ m/^\s*{/) {
      $header .= $_;
    }
    $header .= $_;
    ProcessHeader($header);
    $header = "";
  }
}


sub ProcessHeader( $ ) {
  my ($header) = @_;
  my ($cprimname, $primname, $req, $opt, $var, $argslist) =
    $header =~ m%^SCWM_PROC\s*\(\s*([^, \t]*),\s*\"([^\"]*)\"\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*\(([^)]*)\)%;
  my ($comment) = $header =~ m%/\*\*\s*(.*)\s*\*/%s;
  my ($fname_define) = $header =~ m%^\s*\#\s*define\s+FUNC_NAME\s+(.*?)\s*$%m;

{ # cperl-mode gets confused at above regexp, so provide scope to help it out
  my $clean_argslist = $argslist;
  my $cremovals = ($clean_argslist =~ s/\bSCM\b//g);
  $clean_argslist =~ s/\n/ /g;
  $clean_argslist =~ s/[ \t]+//g;
  $clean_argslist =~ s/_/-/g;
  my @args = split(/,/, $clean_argslist);

  # now create a hash of the names for testing words in the comment
  # whether they are referring to formal parameters
  my %argnames = map {uc($_) => 1} @args;

  if ($cremovals != scalar(@args) ) {
    print STDERR "$ARGV:$.:****$cprimname: types inconsistency (all args should be type SCM)\n";
  }

  if (($req + $opt + $var) != scalar(@args)  ) {
    print STDERR "$ARGV:$.:****$cprimname: argument inconsistency -- check #s of arguments\n";
  }

  if ($var != 0 && $var != 1) {
    print STDERR "$ARGV:$.:****$cprimname: number of variable arguments == $var -- why?\n";
  }

  if (!defined($comment) || $comment eq "") {
    print STDERR "$ARGV:$.:****$cprimname: comment missing\n";
    $comment = "";
  }

  if (!defined($fname_define)) {
    print STDERR "$ARGV:$.:****$cprimname: #define FUNC_NAME s_$cprimname is missing\n";
  } elsif ($fname_define ne "s_".$cprimname) {
    print STDERR "$ARGV:$.:****$cprimname: #define FUNC_NAME does not match function name\n";
  }

  my @required_args = @args[0..($req-1)];
  my @optional_args = @args[$req..($req + $opt - 1)];
  my @var_args = @args[($req+$opt)..($req+$opt+$var-1)];

  my $arg_listing = "";
  if ($#args >= 0) {
    $arg_listing .= "@required_args";
    if ($#optional_args >= 0) {
      $arg_listing .= " #&optional @optional_args";
    }
    if ($#var_args >= 0) {
      $arg_listing .= " . @var_args";
    }
  }

  my $usage = sprintf "($primname%s$arg_listing)", ($arg_listing ne ""? " ":"");


  if ($fDebug) {
    print <<EOC
scheme-primitive-name:	$primname
C-primitive-name:	$cprimname
arg kinds:		$req, $opt, $var
args:			@args
arg listing:		$arg_listing
fname define:           $fname_define
EOC
;
  }
  print <<EOC
usage:			$usage
comment:		$comment
EOC
  ;
  print "\n";
} # end helper scope
  
}
