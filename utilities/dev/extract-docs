#!/uns/bin/perl -w
# $Id$ -*- perl -*-
# extract-docs
# By Greg J. Badros -- 7-July-1998
#
# extract-docs pulls out the SCWM_PROC declarations and comments
# from a SCWM .c source file and processes them to create
# documentation
#
# Usage: extract-docs <filenames-to-extract-from>
#
# e.g.,
#
# extract-docs *.c
#
# Goal:
# Ultimately, this should output tagged sgml suitable for sgml-doc
# Right now, it just does the extraction into high-level elements w/o
# adding the logical tags
#
# Note that it does lots of important error checking, and produces error and warning
# messages that look like grep, so emacs' compile-mode (and probably grep-mode)
# can be used to find problems with the documentation using M-x compile (C-x c)
#   extract-docs *.c > /dev/null
# then M-x next-error (C-x `)
#
# TODO:
# Generate DocBook output!
#
# BUGS:
# This should probably be written in guile-scheme instead of perl
#

use strict;
use constant TRUE => (1==1);
use constant FALSE => (1==0);
use File::Basename;

my $pkg_name = basename($ENV{PWD});

my $header = "";
#my $fDebug = TRUE;
my $fDebug = FALSE;

# maps from a procedure name to a hash
# containing "usage", "purpose", "comment",  "markup", "file", "line"
my %procedure = ();
# maps from a filename to a list reference containing the names of 
# primitives defined in that file
my %file_funcs = ();

while (<>) {
  close(ARGV) if (eof);
  if (m/^SCWM_PROC/) {
    $header = $_;
    while (($_ = <>) !~ m/^\s*\{/) {
      $header .= $_;
    }
    $header .= $_;
    ProcessHeader($header);
    $header = "";
  }
}

open (MARKUP_OUT,">$pkg_name.sgml") or die "Could not write to $pkg_name.sgml: $!";
chop (my $date = `date +"%d %B %Y"`);
chop (my $year = `date +"%Y"`);

print MARKUP_OUT <<END_HEADER
<!DOCTYPE Book PUBLIC "-//Davenport//DTD DocBook V3.0//EN">
<book>
  <bookinfo>
    <title>
      <productname>SCWM Reference Manual</productname>
    </title>
    <authorgroup>
      <author>
  	<firstname>Maciej</firstname>
  	<surname>Stachowiak</surname>
  	<affiliation>
  	  <shortaffil>MIT</shortaffil>
  	  <jobtitle>M.S. Degree Recipient</jobtitle>
  	  <orgname>Massachusetts Institute of Technology</orgname>
  	  <orgdiv>Department of Computer Science</orgdiv>
  	  <address>
  	    <city>Cambridge</city>
  	    <state>Massachusetts</state>
  	    <postcode>12345</postcode>
  	    <country>U.S.A.</country>
  	    <email>mstachow\@mit.edu</email>
  	  </address>
  	</affiliation>
      </author>
      <author>
  	<firstname>Greg</firstname>
  	<surname>Badros</surname>
  	<affiliation>
  	  <shortaffil>UWashington</shortaffil>
  	  <jobtitle>Graduate Research Assistant</jobtitle>
  	  <orgname>University of Washington</orgname>
  	  <orgdiv>Department of Computer Science and Engineering</orgdiv>
  	  <address>
  	    <city>Seattle</city>
  	    <state>Washington</state>
  	    <postcode>98195</postcode>
  	    <country>U.S.A.</country>
  	    <email>gjb\@cs.washington.edu</email>
  	  </address>
  	</affiliation>
      </author>
    </authorgroup>
    <releaseinfo>Release pre-0.8</releaseinfo>
    <pubdate>$date</pubdate>
    <copyright>
      <year>1997&ndash;$year</year>
      <holder>Maciej Stachowiak and Greg J. Badros</holder>
    </copyright>
  </bookinfo>
  <chapter>
    <title>Primitives in Alphabetical Order</title>
END_HEADER
;

foreach my $proc (sort { lc($a) cmp lc($b) } keys %procedure) {
  my $usage = $procedure{$proc}{usage};
  my $comment = $procedure{$proc}{comment};
  my $file = $procedure{$proc}{file};
  my $line = $procedure{$proc}{line};
  my $markup = $procedure{$proc}{markup};
  print <<EOC
$usage
$comment
[From $file:$line]

EOC
  ;
  print MARKUP_OUT $markup, "\n";
}

# FIXGJB: use links, not re-output!  Probably just
# use an index for alpha ordering?
print MARKUP_OUT <<END_CHAP_PRIM_IN_ALPHA
  </chapter>
  <chapter>
    <title>Primitives By Defined-in File</title>
END_CHAP_PRIM_IN_ALPHA
  ;

foreach my $file (sort { lc($a) cmp lc($b) } keys %file_funcs) {
  my @prims = @{$file_funcs{$file}};
  if (scalar(@prims) > 0) {
    print MARKUP_OUT "    <sect1><title>$file</title>\n";
    foreach my $proc (sort { $procedure{$a}{line} <=> $procedure{$b}{line} } @prims ) {
      my $usage = $procedure{$proc}{usage};
      my $comment = $procedure{$proc}{comment};
      my $line = $procedure{$proc}{line};
      my $markup = $procedure{$proc}{markup};
      print MARKUP_OUT $markup, "\n";
    }
    print MARKUP_OUT "    </sect1>\n";
  }
}



print MARKUP_OUT <<END_TRAILER
</chapter>
</book>
<!-- Keep this comment at the end of the file
Local variables:
mode: sgml
fill-column: 10000
sgml-omittag:nil
sgml-shorttag:t
End:
-->
END_TRAILER
;


sub ProcessHeader( $ ) {
  my ($header) = @_;
  my ($cprimname, $primname, $req, $opt, $var, $argslist) =
    $header =~ m%^SCWM_PROC\s*\(\s*([^, \t]*),\s*\"([^\"]*)\"\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*\(([^\)]*)\)%;
  if (!defined($cprimname)) {
    print STDERR "$ARGV:$.:****ERROR:could not parse argument list\n";
    return FALSE;
  }
  my ($comment) = $header =~ m%/\*\*\s*(.*)\s*\*/%s;
  my ($fname_define) = $header =~ m%^\s*\#\s*define\s+FUNC_NAME\s+(.*?)\s*$%m;
  
  my $clean_argslist = $argslist;
  my $cremovals = ($clean_argslist =~ s/\bSCM\b//g);
  $clean_argslist =~ s/\n/ /g;
  $clean_argslist =~ s/[ \t]+//g;
  $clean_argslist =~ s/_/-/g;
  $clean_argslist =~ s/-[pP]\b/?/g;
  $clean_argslist =~ s/-[xX]\b/!/g;
  my @args = split(/,/, $clean_argslist);

  # now convert the c function name into the expected (preferred) primitive name:
  my $expected_primname = $cprimname;
  $expected_primname =~ s/_/-/g;
  $expected_primname =~ s/-[pP]\b/?/g;
  $expected_primname =~ s/-[xX]\b/!/g;
  # alternative possibility (ignoring chance of multiple to's in string)
  my $expected_primname2 = $expected_primname;
  $expected_primname2 =~ s/-to-/->/g;

  
  # now create a hash of the names for testing words in the comment
  # whether they are referring to formal parameters
  my %argnames = map { uc($_) => 1} @args;

  if ($primname ne $expected_primname && $primname ne $expected_primname2) {
    print STDERR "$ARGV:$.:****$cprimname: expected scheme primitive named \`$expected_primname\'\n";
  }

  if ($cremovals != scalar(@args) ) {
    print STDERR "$ARGV:$.:****$cprimname: types inconsistency (all args should be type SCM)\n";
  }

  if (($req + $opt + $var) != scalar(@args)  ) {
    print STDERR "$ARGV:$.:****$cprimname: argument inconsistency -- check #s of arguments\n";
  }

  if ($var != 0 && $var != 1) {
    print STDERR "$ARGV:$.:****$cprimname: number of variable arguments == $var -- why?\n";
  }

  if (!defined($comment) || $comment eq "") {
    print STDERR "$ARGV:$.:****$cprimname: comment missing\n";
    $comment = "";
  }

  if (!defined($fname_define)) {
    print STDERR "$ARGV:$.:****$cprimname: \`#define FUNC_NAME s_$cprimname\' is missing\n";
  } elsif ($fname_define ne "s_".$cprimname) {
    print STDERR "$ARGV:$.:****$cprimname: \`#define FUNC_NAME s_$cprimname\' does not match function name \`$fname_define\'\n";
  }

  my @required_args = @args[0..($req-1)];
  my @optional_args = @args[$req..($req + $opt - 1)];
  my @var_args = @args[($req+$opt)..($req+$opt+$var-1)];

  my $arg_listing = "";
  if ($#args >= 0) {
    $arg_listing .= "@required_args";
    if ($#optional_args >= 0) {
      $arg_listing .= " #&optional @optional_args";
    }
    if ($#var_args >= 0) {
      $arg_listing .= " . @var_args";
    }
  }

  my $usage = sprintf "($primname%s$arg_listing)", ($arg_listing ne ""? " ":"");

  my %upcase_words = ();

  # check to make sure all all-uppercase words in the comment
  # refer to formals
  foreach my $word (split /[^-+?!\w_\"]+/, $comment) {
    if ($word =~ /^[A-Z][-A-Z0-9_+?!]+$/) {
      if (!defined($argnames{$word})) {
	print STDERR "$ARGV:$.:****$cprimname: all-uppercase word \`$word\' does not match an argument\n";
      }
    }
  }

  # check to make sure all formals are referred to in the comment
  # warning is #**** since these are less severe problems and one
  # may choose to filter them
  foreach my $formal (keys %argnames) {
    if ($comment !~ /\Q$formal\E/) {
      print STDERR "$ARGV:$.:\#***$cprimname: formal $formal not mentioned in comment\n";
    }
  }

  my ($purpose) = $comment =~ m%(.*?[\.;\n])%;
  if (!defined $purpose) {
    # did not match, so must have been a one-liner w/o a newline
    $purpose = $comment;
  }
  chomp ($purpose); # in case it matched the newline
  if (!defined($purpose) || $purpose !~ /\.\s*$/) {
    print STDERR "$ARGV:$.:****$cprimname: first line of comment should be a purpose sentence\n";
  }

  # Now want to do the markup of $comment, and set $markup_comment
  # FIXGJB: fold into testing, above
  my $markup_comment = $comment;

  # convert & into &amp; space-delimited <, > into &lt; and &gt;
  $markup_comment =~ s%&%&amp;%g;
  $markup_comment =~ s%<%&lt;%g;
  $markup_comment =~ s%>%&lt;%g;
  $usage =~ s%&%&amp;%g;
  $usage =~ s%(\s+)<(\s+)%$1&lt;$2%g;
  $usage =~ s%(\s+)>(\s+)%$1&gt;$2%g;


  # Mark formals within comment with <parameter> tag
  # must sort by length so longer formals get replaced first
  # note that it is essential to convert to lowercase as we
  # go, otherwise shorter substitutions will be made inside
  # an already-substitued <param> </param> pair
  foreach my $formal (sort { length($b) <=> length($a) } keys %argnames) {
    $markup_comment =~ s%(\Q$formal\E)%<parameter>\L$1\E</parameter>%g;
  }
  # Mark #t and #f within comment with <literal> tag
  $markup_comment =~ s%(\#[tf])%<literal>$1</literal>%g;

  # Replace `procedure' with <function>procedure</function>
  $markup_comment =~ s%\`([A-Za-z][-A-Za-z0-9_?!+]*?)\'%<function>$1</function>%g;

  # FIXGJB: use some sgml perl library!

  # Use <refentry>, <refname>, <refpurpose>, <synopsis>
  my $filename = $ARGV;
  my $linenum = $.;
  
  my $markup = 
"<refentry>
  <refnamediv>
    <refname>$primname</refname>
    <refpurpose>$purpose</refpurpose>
  </refnamediv>
  <refsynopsisdiv>
    <synopsis>$usage</synopsis>
  </refsynopsisdiv>
  <refsect1>
  <title>Description</title>
  <para>
  $markup_comment
  </para>
  </refsect1>
  <refsect1>
  <title>Implemenation Notes</title>
  <para> Defined in <filename>$ARGV</filename> at line $. </para> </refsect1>
</refentry>
";


  if ($fDebug) {
    print STDERR <<EOC
scheme-primitive-name:	$primname
C-primitive-name:	$cprimname
arg kinds:		$req, $opt, $var
args:			@{[join(",",@args)]}
arg listing:		$arg_listing
fname define:           $fname_define
EOC
;
  }
  $procedure{$primname} = { usage => $usage,
			    comment => $comment,
			    purpose => $purpose,
			    markup => $markup,
			    file => $ARGV,
			    line => $.,
			  };
  push @{$file_funcs{$ARGV}}, $primname;

  return TRUE;
}
