
(define broadcast-hook #f)
(define broadcast-config-hook #f)
(define broadcast-name-hook #f)

(define-module (fvwm-module-test)
  :use-module (ice-9 string-fun)
  :use-module (app scwm base))

(define app-window "0")
(define context "0") ; C_NO_CONTEXT
(define first-desktop "0")
(define last-desktop "1")

(define current-desk 0)
(define display-width (car (display-size)))
(define display-height (cadr (display-size)))



(define M_NEW_PAGE  1)
(define M_NEW_DESK  2)
(define M_ADD_WINDOW  4)
(define M_RAISE_WINDOW  8)
(define M_LOWER_WINDOW  16)
(define M_CONFIGURE_WINDOW  32)
(define M_FOCUS_CHANGE  64)
(define M_DESTROY_WINDOW  128)
(define M_ICONIFY  256)
(define M_DEICONIFY  512)
(define M_WINDOW_NAME  1024)
(define M_ICON_NAME  2048)
(define M_RES_CLASS  4096)
(define M_RES_NAME  8192)
(define M_END_WINDOWLIST  16384)
(define M_ICON_LOCATION  32768)
(define M_MAP  65536)
(define M_ERROR  131072)
(define M_CONFIG_INFO  262144)
(define M_END_CONFIG_INFO  524288)
(define M_ICON_FILE  1048576)
(define M_DEFAULTICON  2097152)
(define M_STRING  4194304)
(define M_MINI_ICON  8388608)
(define M_WINDOWSHADE  16777216)
(define M_DEWINDOWSHADE  33554432)


(define (test-bitness-and-endianness)
  (let* ((p (pipe))
	 (read-pipe (car p))
	 (write-pipe (cdr p))
	 (u (make-uniform-array #x0f0000ff 1)))
    (uniform-array-write u write-pipe)
    (close write-pipe)
    (let ((s
	   (let loop ((c (read-char read-pipe))
		      (s ""))
	     (if (eof-object? c)
		 s
		 (loop (read-char read-pipe)
		       (string-append s (string c)))))))
      (close read-pipe)
      (cons (* 8 (string-length s)) 
	    (char=? (string-ref s 0) (integer->char 255))))))

(define bitness #f)
(define endianness #f)

(let ((b&e (test-bitness-and-endianness)))
  (set! bitness (car b&e))
  (set! endianness (cdr b&e)))

(define long->string 
  (if (= bitness 32)
      (if endianness
	  ;; 32-bit little-endian
	  (lambda (int)
	    (let* ((s (make-string 4 #\nul))
		   (intx (if (> int 2147483647)
			     (- int 4294967296)
			     int)))
	      (string-set! s 3 
			   (integer->char (ash intx -24)))
	      (string-set! s 2 
			   (integer->char (logand #x000000ff (ash intx -16))))
	      (string-set! s 1 
			   (integer->char (logand #x000000ff (ash intx -8))))
	      (string-set! s 0 
			   (integer->char (logand #x000000ff intx)))
	      s))
	  ;; 32-bit big-endian
	  (lambda (int)
	    (let* ((s (make-string 4 #\nul))
		   (intx (if (> int 2147483647)
			     (- int 4294967296)
			     int)))
	      (string-set! s 0 
			   (integer->char (ash intx -24)))
	      (string-set! s 1 
			   (integer->char (logand #x000000ff (ash intx -16))))
	      (string-set! s 2 
			   (integer->char (logand #x000000ff (ash intx -8))))
	      (string-set! s 3 
			   (integer->char (logand #x000000ff intx)))
	      s)))
      (if endianness
	  ;; 64-bit little-endian
	  (lambda (int)
	    (let* ((s (make-string 4 #\nul))
		   (intx (if (> int 9223372036854775809)
			     (- int 18446744073709551616)
			     int)))
	      (string-set! s 7 
			   (integer->char (ash intx -56)))
	      (string-set! s 6 
			   (integer->char (logand #x000000ff (ash intx -48))))
	      (string-set! s 5 
			   (integer->char (logand #x000000ff (ash intx -40))))
	      (string-set! s 4 
			   (integer->char (logand #x000000ff (ash intx -32))))
	      (string-set! s 3 
			   (integer->char (logand #x000000ff (ash intx -24))))
	      (string-set! s 2 
			   (integer->char (logand #x000000ff (ash intx -16))))
	      (string-set! s 1 
			   (integer->char (logand #x000000ff (ash intx -8))))
	      (string-set! s 0 
			   (integer->char (logand #x000000ff intx)))
	      s))
	  ;; 64-bit big-endian
	  (lambda (int)
	    (let* ((s (make-string 4 #\nul))
		   (intx (if (> int 9223372036854775809)
			     (- int 18446744073709551616)
			     int)))
	      (string-set! s 0 
			   (integer->char (ash intx -56)))
	      (string-set! s 1 
			   (integer->char (logand #x000000ff (ash intx -48))))
	      (string-set! s 2 
			   (integer->char (logand #x000000ff (ash intx -40))))
	      (string-set! s 3 
			   (integer->char (logand #x000000ff (ash intx -32))))
	      (string-set! s 4 
			   (integer->char (logand #x000000ff (ash intx -24))))
	      (string-set! s 5 
			   (integer->char (logand #x000000ff (ash intx -16))))
	      (string-set! s 6 
			   (integer->char (logand #x000000ff (ash intx -8))))
	      (string-set! s 7 
			   (integer->char (logand #x000000ff intx)))
	      s)))))

(define pad-string-to-long
  (if (= bitness 32)
      ;; 32 bit
      (lambda (str)
	(let* ((length (* 4 (+ 1 (inexact->exact 
				  (floor (/ (string-length str) 4))))))
	       (pad (- length (string-length str))))
	  (string-append 
	   str 
	   (apply string (make-list pad #\nul)))))
      ;; 64 bit
      (lambda (str)
	(let* ((length (* 8 (+ 1 (inexact->exact 
				  (floor (/ (string-length str) 4))))))
	       (pad (- length (string-length str))))
	  (string-append 
	   str 
	   (apply string (make-list pad #\nul)))))))

(define (data-write str port)
  (uniform-array-write str port))

(define (data-read length port)
  (let* ((s (make-string length))
	 (result (uniform-array-read! s port)))
    (if (< result length)
	(throw 'too-little)
	s)))

(define (read-int port)
  (let* ((u (make-uniform-array #xfffffff 1))
	 (result (uniform-array-read! u port)))
    (if (< result 1)
	(throw 'too-little)
	(array-ref u 0))))

(define (fvwm2-module-read-packet port)
  (define (wait-for-input)
    (if (char-ready? port)
	#t
	(let ((result (select (list (fileno port))
			      '() '() 100 100)))
	  (if (null? (car result))
	      (wait-for-input)
	      result))))
  (wait-for-input)
  (let* ((window
	  (catch #t (lambda () (read-int port))
		 (lambda args (error "Could not get window id"))))
	 (msglen
	  (catch #t (lambda () (read-int port))
		 (lambda args (error "Could not get msglen"))))
	 (command
	  (catch #t (lambda () (data-read msglen port))
		 (lambda args (error "Could not get command"))))
	 (keepgoing
	  (catch #t (lambda () (read-int port))
		 (lambda args (error "Could not get keepgoing")))))
	 (list window msglen command keepgoing)))

(define (fvwm2-module-send-config-info config-info port)
  (map (lambda (x) (send-config-info x port))
       config-info
       )
  (send-end-config-info port))

(define (make-packet-header id body-length)
  (apply string-append
	 (map long->string 
	      (list #xffffffff id (+ body-length 4) (current-time)))))

(define (fvwm2-module-send-packet id body port)
  (if (not (= (modulo (string-length body)  4) 0))
      (error "Bad packet length"))
  (data-write 
   (string-append (make-packet-header id (/ (string-length body) 4))
		  body) port)
  (force-output port))

(define (send-end-config-info port)
  (fvwm2-module-send-packet M_END_CONFIG_INFO "" port))

(define (send-config-info str port)
  (let* ((data (string-append 
		(long->string 0)
		(long->string 0)
		(long->string 0)
		(pad-string-to-long str))))
    (fvwm2-module-send-packet M_CONFIG_INFO data port)))

(define (fvwm2-module-send-window-list port)
  (map (lambda (w) (add-window w port)) (list-all-windows))
  (end-window-list port))

(define (id->window id)
  (let ((candidates (list-windows 
		     #:only (lambda (w) (= (window-id w) id)))))
    (if (not (null? candidates))
	(car candidates)
	#f)))

(define (add-window win port)
  (fvwm2-module-send-packet 
   M_ADD_WINDOW 
   (marshal-fvwm2-config-info win)
   port))

(define (end-window-list port)
  (fvwm2-module-send-packet M_END_WINDOWLIST "" port))

(define (add-input-hook-checking port thunk)
  (if (char-ready? port)
      (thunk)
      (add-input-hook (fileno port) thunk)))

(define module-broadcast-hooks '())

(set! broadcast-hook (lambda args  
		       (map (lambda (x) (apply x args)) 
			    module-broadcast-hooks)))

(define module-broadcast-config-hooks '())

(set! broadcast-config-hook (lambda args  
			      (map (lambda (x) (apply x args)) 
				   module-broadcast-config-hooks)))

(define module-broadcast-name-hooks '())

(set! broadcast-name-hook (lambda args  
		       (map (lambda (x) (apply x args)) 
			    module-broadcast-name-hooks)))

(define (fvwm2-module-run module-file config-file config-info)
  (let* ((from-module-pipe (pipe))
	 (from-module-read (car from-module-pipe))
	 (from-module-write (cdr from-module-pipe))
	 (to-module-pipe (pipe))
	 (to-module-read (car to-module-pipe))
	 (to-module-write (cdr to-module-pipe))
	 (pid (primitive-fork))
	 (mask 0))
    
    ;; $SIG{'CHLD'} = sub { wait };
    ;; Need to look up how to provide sigchld handler
    (cond
     ((= pid 0)
      ;; child process
      (close-port to-module-write)
      (close-port from-module-read)
      (let ((write-fd (number->string (fileno from-module-write)))
	    (read-fd (number->string (fileno to-module-read))))
	(display (string-append 
		  "child: " module-file " " write-fd " " read-fd " " config-file 
		  " " app-window " " context " " first-desktop " " 
		  last-desktop "\n") (current-output-port))
	(execl module-file module-file write-fd read-fd config-file 
	       app-window context first-desktop last-desktop))
      (display "Exec failed.\n")
      (exit 0)))

    ;; parent process

    (close-port to-module-read)
    (close-port from-module-write)

    ;; FIXGJB: mark fd-s close-on-exec so other processes won't inherit them
    ;; FIXGJB: set o_nonblock for TO_MODULE_WR
    ;; GJBFIX: why is that necessary?
    ;; (fctl to-module-write F_SETFL O_NONBLOCK)

    (set! module-broadcast-hooks
	  (cons (lambda (type num-data . args)
		  (if (logior type mask)
			(fvwm2-module-send-packet 
			 type
			 (apply string-append
				(map (lambda (x y) 
				       (long->string x)) 
				     args (iota num-data))) 
			 to-module-write)))
		module-broadcast-hooks))

    (set! module-broadcast-config-hooks
	  (cons (lambda (type window)
		  (if (logior type mask)
		      (fvwm2-module-send-packet 
		       type
		       (marshal-fvwm2-config-info window)
		       to-module-write)))
		module-broadcast-config-hooks))

    (set! module-broadcast-name-hooks
	  (cons (lambda (type data1 data2 data3 name)
		  (if (logior type mask)
		      (fvwm2-module-send-packet 
		       type
		       (pad-string-to-long
			(string-append
			 (long->string data1) 
			 (long->string data2) 
			 (long->string data3)
			 name))
		       to-module-write)))
		module-broadcast-name-hooks))

    (letrec 
	((packet-handler
	  (lambda ()
	    (let* ((packet (fvwm2-module-read-packet from-module-read))
		   (window-id (car packet))
		   (command (caddr packet))
		   (split-result (split-before-char #\space command 
						    (lambda args args)))
		   (main-cmd (car split-result))
		   (args (cadr split-result)))	
	      
	      ;; (display "packet: ")
	      ;; (write packet)
	      ;; (newline)
	      (cond
	       ((string-ci=? main-cmd "Send_ConfigInfo") 
		(fvwm2-module-send-config-info config-info to-module-write))
	       ((string-ci=? main-cmd "Send_WindowList") 
		(fvwm2-module-send-window-list to-module-write))
	       ((string-ci=? main-cmd "Move")
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (first-arg (string->number 
				   (sans-surrounding-whitespace (car s-args)))))
		  ;; just move, count on callback code to
		  ;; DTRT WRT sending data back to module.
		  (move-to first-arg (id->window window-id))))
	       ((string-ci=? main-cmd "WindowsDesk")
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (first-arg (string->number 
				   (sans-surrounding-whitespace (car s-args)))))
		  ;; just move to the new desk, count on callback code to
		  ;; DTRT WRT sending data back to module.
		  (move-window-to-desk first-arg (id->window window-id))))
	       ((string-ci=? main-cmd "Raise")
		;; just raise, count on callback code to
		;; DTRT WRT sending data back to module.
		(raise-window (id->window window-id)))
	       ((string-ci=? main-cmd "Scroll")
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (first-arg (string->number 
				   (sans-surrounding-whitespace (car s-args))))
		       (second-arg (string->number 
				    (sans-surrounding-whitespace 
				     (cadr s-args)))))
		  ;; just set the viewport position, count on callback code to
		  ;; DTRT WRT sending data back to module.
		  (move-viewport first-arg second-arg)))
	       ((string-ci=? main-cmd "GotoPage")
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (first-arg (string->number 
				   (sans-surrounding-whitespace (car s-args))))
		       (second-arg (string->number 
				    (sans-surrounding-whitespace 
				     (cadr s-args)))))
		  ;; just set the viewport position, count on callback code to
		  ;; DTRT WRT sending data back to module.
		  (set-viewport-position! 
		   (* first-arg display-width)
		   (* second-arg display-height))))
	       ((string-ci=? main-cmd "Desk")
		;; just set the desk position, count on callback code to
		;; DTRT WRT sending data back to module.
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (second-arg (string->number 
				    (sans-surrounding-whitespace 
				     (cadr s-args)))))
		  (set-current-desk! second-arg)))
	       ((string-ci=? main-cmd "Set_mask")
		(let* ((s-args (split-after-char 
				#\space 
				(sans-leading-whitespace args)
				(lambda args args)))
		       (first-arg (string->number 
				   (sans-surrounding-whitespace 
				    (car s-args)))))
		  (set! mask first-arg)))))
	    (add-input-hook-checking from-module-read packet-handler))))
      (add-input-hook-checking from-module-read packet-handler))))

(fvwm2-module-run  
 "/mit/windowmanagers/lib/X11/fvwm2/FvwmPager"
 "~/.fvwm2rc"
 '("*FvwmPagerBack grey76"
   "*FvwmPagerFore black"
   "*FvwmPagerHilight navyblue"
   "*FvwmPagerFont none"
   "*FvwmPagerDeskTopScale 40"
   "*FvwmPagerLabel 0 Top"
   "*FvwmPagerLabel 1 Bottom"
   "*FvwmPagerSmallFont 5x8"))


