

SCWM Scheme function documentation :

The scwm configuration file is a Guile Scheme program. All of the
usual Guile procedures are available. In addition, the following
windowmanager-sepcific procedures have been implemented. See the
sample system.scwmrc file for examples. The fvwm2 man page may be
helpful for understanding some of the procedures or especially style
options until I write better documentation.

Documentation style:

A procedure documented as 
(foo BAR BAZ #&optional QUUX XYZZY . ARGS) 

is called foo and has required arguments BAR and BAZ, optional
arguments QUUX and XYZZY, and accepts any variable number of arguments
beyond that. All the specifications follow this pattern.


FONTS:

(load-font FONTNAME) 

This loads a font specified by the string FONTNAME and returns a font
object. All proocedures which expect a font can take either a font
object or a string specifier (in which case they automatically call
load-font themselves) but it you want to use a font many times is
more efficient to do something like :
(define helvetica 
  (load-font "-adobe-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))


(font? OBJ)
Returns #t if OBJ is a font object, else #f.

(set-icon-font! FONT)
(set-window-font! FONT)
(set-menu-font! FONT)

These set the icon, titlebar and menu fonts respectively.


COLORS:

(load-color COLORNAME)

load-color basically works like load-font, except 

(color? OBJ)
Returns #t if OBJ is a color object, else #f.

(set-hilight-colors! #&optional FG BG)

Sets the hilight foreground and background colors. If you pass #f for
either one, it is left unchanged.

(set-menu-colors! #&optional FG BG STIPPLE)

This sets the menu foreground, background and stipple colors. As
above, #f indicates that the relevant color should not be changed.


BINDINGS:

(bind-key CONTEXTS KEY-SPECIFIER PROC)

This establishes a key binding. CONTEXTS specifies the context(s) in
which it will be in effect. It can be one of the following symbols or
a list of several:

window, title, icon, root, frame, sidebar, button-1, button-2,
button-3, button-4, button-5, button-6, button-7, button-8, button-9,
button-10, all

Using 'all as the context includes all of the others.

The key to bind is specified as a string, sort of emacs-style. Some
examples: 

"x","F1","C-x","M-space","C-M-a"

Basically, you give a characer or a keysym prefixed by any combination
of "C-", "M-" and "S-" representing Control, Meta and Shift
respectively. Other prefixes that emacs understands will be
implemented as soon as I understand what they do in emacs.

The proc is a Scheme procedure of no arguments. If the key binding is
invoked from within anywhere but the root window, the current window
context is set to the window it was invoked from. Window contexts are
explained in the section on window operations.

(unbind-key CONTEXTS KEY-SPECIFIER)

Removes the binding set for the specified key in the specified set
of contexts.

(bind-mouse CONTEXTS BUTTON-SPECIFIER PROC)

Works much like bind-key above, but binds to a mouse action. In
addition to possibly setting the window context, it also sets the
current mouse event type so that the type of mouse event can be
distiguished from the procedure. This is explained in the section on
mouse-event-type below.

Mouse button specifiers are either numbers or strings that consist of
a number with optional prefixes specifying modifier
keys. mouse-<number> may be used as well. Here are some valid mouse
specifiers:

1
2
"M-1"
"C-M-2"
"mouse-3"
"S-mouse-1"

(unbind-mouse CONTEXTS BUTTON-SPECIFIER)

Removes the binding set for the specified mouse event in the specified
set of contexts.

(mouse-event-type)

If called from code that was invoked by a mouse binding, it returns
the type of mouse event, one of 'motion 'click 'one-and-a-half-clicks
or 'double-click. This can be used in conjunction with Scheme's case
or cond special forms to do different things based on the type of
event. This functionality may go away in favor of being able to bind
any kind of mouse event type separately.


(bind-event EVENT PROC)

Binds a special windowmanager event to some special action. Currently
defined events are:

'new-window - the procedure is called whenever a new window is created
with no arguments and with the new window as the current window
context. It is useful for specifying initial style options and
parameters and such. It is not reccomended to use this event directly;
instead, see the window-style procedure in the (app scwm style) module.

'new-window-hint - this event works much like 'new-window except that
the procedure is called much earlier in the window creation
process. At this point most normal window procedures won't
work. However, some, such as those that specify which position hints
to obey and what type of placement to use must be used this early in
the creation process so that the window can be put in the right
place. This dichotomy is somewhat bogus and will probably be fixed
later. If you access this functionality through the window-style
procedure you shouldn't have to worry about this.



MISCELLANEOUS SETTINGS:

(set-menu-mwm-style! BOOL)

Determines if menus are MWM style or FVWM style.

(set-rubber-band-mask! INT)

Sets the XOR mask value used for rubber-banding windows.

(set-title-height! INT)

Sets the height of the title-bar.

(set-title-justify! SYM)

Sets the title-bar justification. The symbol must be one of 'left,
'right or 'center.

(set-click-time! INT)

Sets the maximum time that must elapse after a mouse can be pressed
and not yet released that will still be interpreted as a click and not
a motion. The time is given in milliseconds. The default is 150.

(set-colormap-focus! SYM)
Sets the colormap focus style, either 'focus or 'mouse. In the first
case, the window with keyboard focus has the colormap focus, in the
other case, the colormap focus follows the mouse even if the keyboard
focus doesn't.

(set-opaque-move-size! INT)
Sets the largest window size that will be moved opaquely rather than
with rubber-banding, as percentage of screen size. 0 will make all
windows rubber-band when they move, while 100 will make all windows
move as solid. The default

(set-smart-placement-is-really-smart! BOOL)
(set-click-to-focus-passes-click! BOOL)
(set-click-to-focus-raises! BOOL)
(set-mouse-focus-click-raises! BOOL)

(set-animation! VECTOR);

animation-ms-delay 



MISCELLANEOUS OPERATIONS:

(refresh)

Refreshes the whole screen.

(pointer-position)

Returns a list of the current x and y coordinates of the mouse cursor.

(recapture)

(restart NEW-WM)

(wait-for-window PREDICATE)

(beep)

My suggested definition in Scheme is not adequate for remote displays - the
new (tiny) C implementation using XBell should take care of this.

SYNTHETIC EVENTS:

(move-pointer-to X Y)

Moves the pointer to the absolute position X,Y.

(send-button-press button modifier #&optional win button_press_p 
		   button_release_p propagate_p)
(send-key-press key #&optional win button_press_p button_release_p 
		propagate_p)

Send synthetic button and key presses.


WINDOWS: 


(window? OBJ)
Returns #t if OBJ is a window object, else #f.

(get-window #&optional USE_KILL_CURSOR USE_SELECT_WINDOW WAIT_FOR_RELEASE) 

Retrieves the current window context and returns the window object
representing it. If no window context is set, it lets the user select
a window by ccalling select-window. However, select-window is not
really implemented yet so it will actually return #f in this case.

The optional arguments are generally not needed in most user code.

(select-window USE_KILL_CURSOR WAIT_FOR_RELEASE)

Interactively selects a window.

The optional arguments are generally not needed in most user code.

(current-window-with-focus)
(current-window-with-pointer)



WINDOW OPERATIONS:

For all of these, the optional window argument defaults to the current
window context. This makes it convenient to bind window operations to
key or mouse events. It also means that in most cases, you won't need
to use the optional W argument, but sometimes it is needed. 

(focus #&optional W)
Give W the keyboard focus.

(warp-to-window #&optional W)
Warp the mouse pointer to the window W.

(delete-window #&optional W)
Delete W, in other words, close it politely. This may not always work.

(destroy-window #&optional W) 
Destroy W, in other words, close it rudely. This always works, but
will not give the application the chance to do special shutdown
actions, like asking for confirmation.

(window-deletable? #&optional W)
Returns #t if delete-window will work on W, else #f.

(lower-window #&optional W)
Lowers W to the bottom of the window stack.

(raise-window #&optional W)
Raises W to the top of the window stack.

(raised? #&optional W)
Returns #t if W is currently raised, else #f.

(iconify #&optional W) 
Iconifies window W.

(deiconify #&optional W) 
Deiconifies window W.

(iconified? #&optional W)
Determines if W is iconified.

(stick #&optional W)
"Sticks" window W. This makes it remain in the same position on the screen
when desks or pages are switched.

(unstick #&optional W)
Reverses the effects of "stick."

(sticky? #&optional W)
Determines if a window is currently "sticky."

(window-shade #&optional W ANIMATED_P)
Rolls up the window into just a title bar, like a window
shade. Optionally animated.


(un-window-shade #&optional W)
Reverses the effect of window-shade.

(window-shaded? #&optional W)
Determines if the window is currently shaded.

(move-to X Y #&optional W ANIMATED_P MOVE_POINTER_TOO_P) 
Moves the window to X,Y on the current screen. The move can optionally
be animated and it is possible to also move the pointer.

(interactive-move #&optional W) 
Begins an interactive move operation. The user can adjust the position
of the window with the mouse or arrow keys.

(resize-to X Y #&optional W)
Resizes the window to X by Y. 

(interactive-resize #&optional W) 
Begins an interactive resize operation. The user can adjust the
position of the window with the mosue or arrow keys.

(refresh-window #&optional W)
Refreshes the window, ensuring that its contents and decorations  are
up to date and properly displayed.

(move-window-to-desk DESK #&optional W)
Moves the window to a new desk, specified by an integer.

(keep-on-top #&optional W)
Will raise the specified window and keep it on top of all other windows 
unless it is explicitly lowered.

(un-keep-on-top #&optional W)
Negates the effects of keep-on-top.

(kept-on-top? #&optional W)
Determines if a window is under the influence of keep-on-top.

WINDOW INFORMATION PROCEDURES:

These procedures return various kinds of information about windows.
They can be useful in selecting only particular windows

(window-position #&optioonal W)
(window-size #&optioonal W)
(window-id #&optioonal W)
(window-desk #&optioonal W)
(window-title #&optioonal W)
(window-class #&optioonal W)
(window-resource #&optioonal W)

(list-all-windows)
This returns a list of all of the windows currently being managed.

WINDOW STYLE OPERATIONS:

For most of these procedures, it is reccomended to access the relevant
functionality through the window-style or style-one-window procedures
rather than the given procedures. The working and arguments can generally
be deduced from the corresponding style option. Further 

(show-titlebar #&optional W)
(hide-titlebar #&optional W)
(titlebar-shown? #&optional W)
(normal-border #&optional W)
(plain-border #&optional W)
(border-normal? #&optional W)
(set-border-width! WIDTH #&optional W)
(stick-icon #&optional W)
(unstick-icon #&optional W)
(icon-sticky? #&optional W)

(set-icon-box! X Y W H BOOL #&optional W)

(set-window-focus! SYM #&optional W) 
available are:
 'click - must click on the window to focus.
 'mouse - the window gains focus as the mouse enters or leaves.
 'sloppy - the window gains focus as the mouse enters, but does not
           lose it if the pointer enters the root window, or a window
           with 'click or 'none focus.
 'none - don't ever give this window focus, even if it is clicked.

(set-window-colors! #&optinal FG BG W)
(set-icon-title! STRING #&optional W)
(set-random-placement! BOOL #&optional W)
(set-smart-placement! BOOL #&optional W)
(set-window-button! NUM BOOL #&optional W)
(set-mwm-buttons! BOOL #&optional W)
(set-mwm-border! BOOL #&optional W)
(set-icon! BOOL-OR-STRING-OR-IMAGE #&optional W)
(set-mini-icon! BOOL-OR-STRING-OR-IMAGE #&optional W)

(set-hint-override! BOOL #&optional W)
(set-decorate-transient! BOOL #&optional W)
(set-mwm-decor-hint! BOOL #&optional W)
(set-mwm-func-hint! BOOL #&optional W)
(set-PPosition-hint! BOOL #&optional W)
(set-OL-decor-hint! BOOL #&optional W)
(set-start-on-desk! DESK #&optional W)
(set-skip-mapping! BOOL #&optional W)
(set-lenience! BOOL #&optional W)


MENUS:

(menu? OBJ)
Returns #t if OBJ is a menu object, else #f.

(make-menu TITLE [(list NAME PROC-OR-MENU)|'title|'separator] ...)

Creates a menu object. The first argument is a string that is the menu
title, however, the title is not necessarily displayed unless so
specified. Arguments are successively one of 'title, 'separator, or a
list of a string and a either procedure of no arguments or another
menu object. Respectively, these result in a title, a separator bar,
or an entry that will call the procedure when selected, or display the
menu as a submenu. It is reccomended that an actual menu object be
specified for submenus rather than a procedure which uses popup to
display the menu, because 


(popup MENU #&optional STICK?)

Pops up the menu. If stick is specified, it determines if the menu
stays up when the mouse is released, assuming it was started in
response to a mouse click. The default is #f.


IMAGES:

(make-image NAME)

Creates a Scheme image object loaded from the first file found in the
image path that matches NAME.

(set-image-path! PATH)

Paths are specified as strings that contain a colon-delimited list of
directories. This will change, as they obviously should be lists,
preferably in an ordinary scheme variable.



VIRTUAL DESKTOP:

(set-current-desk! DESK)
(set-viewport-position! X Y)
(set-edge-scroll! X Y)
(set-edge-wrap! X Y)
(set-edge-resistance! SCROLL-RESISTANCE MOVE-RESISTANCE)
(set-desk-size! X Y)
(display-size)
(desk-size)
(viewport-position)
(current-desk)

DECORS:

(make-decor #&&optional NAME)
(default-decor)
(set-current-decor! DECOR)
(current-decor)
(set-window-decor! DECOR #&optional WINDOW)

FACES:
(make-face FLAGS SPECS)
(set-title-face! ACTIVE_UP_FACE #&optional ACTIVE_DOWN_FACE INACTIVE_FACE)
(set-button-face! NUM ACTIVE_UP_FACE #&optional ACTIVE_DOWN_FACE INACTIVE_FACE)
(set-button-mwm-flag! NUM BOOLEAN)
(set-border-face! ACTIVE_FACE #&optional INACTIVE_FACE) 



PROCEDURES IN SCHEME:

These procedures are written and scheme and are there to provide a
friendlier interface to the builtins.

These two are always available because they are defined in the default
rc code that's built into the binary. They do not accept an optional
window argument since they are meant to be used with mouse or key
bindings and depend on the mouse event type.

(resize-or-raise)
Always raise the window, resize it interactively if the mouse is
moved, and lower on a double-click.

(move-or-raise)
Always raise the window, move it interactively if the mouse is
moved, and lower on a double-click.


The rest of the operations are available in modules. Each set is
prefaced with the proper module name.


MODULE (app scwm base)

(%x x) 

x is treated as a precentage of the horizontal screen size and the
proper value in pixels is returned. This is useful for writing rc
files that don't depend too much on the display size for reasonable
placement.

(%y y)

Just like %x, but for the vertical direction.

(x- x)
(y- y)
(%x- x)
(%y- y)

(w%x x #&optional w) 
(w%y y #&optional w)

These work like %x and %y but give a percentage of the dimensions of
the given window.


(execute command) 

Executes a shell command as a separate process, for example (execute
"xterm") or (execute "cat ~/some-file | grep pattern") or whatever.


(set-menu-foreground! fg)
(set-menu-background! bg)
(set-menu-stipple! st)

These set only one of the menu color components. They may go away
since the menu-style interface is more useful.

(set-window-foreground! fg #&optional w)
(set-window-background! bg #&optional w)

(move-pointer x y) 

Moves the mouse pointer relative to the current position
(move-pointer-to moves it absolutely).

(move-viewport x y)

Moves the viewport relatively (set-viewport-position! does it absolutely)

(menu-style #&key fg foreground bg background stipple font mwm mwm-style) 

This is a general-purpose interface for setting various things that
relate to menus. It is called with keyword-value pairs like so:
(menu-style #:fg "red" #:background "black" #:mwm #t)

This example sets the foreground to red, the background to black, and
the mwm-style to true. The keywords available are:

#:fg or #:foreground - foreground color
#:bg or #:background - background color
#:stipple - stipple color
#:font - font
#:mwm or #:mwm-style - mwm style. If true, menus are "mwm style", else they
are "fvwm style".

(simple-title-style #&key font height justify)

This is a similar interface to the above. The available keywords are

#:font - the titlebar font
#:height - the titlebar height
#:justify - the justification - 'left, 'right or 'center.



MODULE (app scwm winops)

This is a collection of extra window operations. Like the standard
window operations, they default to the current window context if the
window is not specified.

(define*-public ((make-toggling-winop pred neg pos) 
		 #&optional W))

This can be used to define toggling window operations easily. you pass
a predicate which determines if the window has been affected, then a
procedure which undoes the operation, then one which does it, and a
procedure is returned which will do a toggling version of the effect.


(close-window #&optional W)

Delete the window if possible, otherwise destroy it.

(toggle-raise #&optional W)
Raise the window if it is not already on top. If it is, lower it.

(toggle-iconify #&optional W)
Iconify the window if it isn't already, else deiconify it.

(toggle-stick #&optional W)
Stick the window if it isn't already, else unstick it.

(toggle-window-shade #&optional W)
window-shade the window if it isn't already, else un-window-shade it.

(maximize nw nh #&optional W)
Maximizes the window to size nw by nh. If either of nw or nh is 0, the
size in that direction will not be changed. Also, a window maximized
vertically will be moved to the top edge of the display, and a window
maximized horizontally will be moved to the left edge.

(maximized? #&optional W)
Determines if the window is maximized.

(unmaximize #&optional W)
Unmaximizes the window if it is maximized, restoring it to its size
and position previous to any maximize operations.

(toggle-maximize nw nh #&optional W)
A toggling version of maximize.

(print-window #&optional W)
Prints a screen dump of the selected window.

(menu-title)
(menu-separator)
(menu-item menu-item name #&key above-pixmap left-pixmap action)


MODULE (app scwm winlist)

This module includes procedures for manipulating the window list.


(default-winlist-proc #&optional w)
This is the normal default window list procedure. It deiconifies,
focuses and raises the window, then warps the pointer to a convenient
point inside it.

window-list-proc

This varibale holds the procedure that will be applied by default to
the window selected from the window list menu. It is normally
default-winlist-proc, but you can set! it to something else to make
that the default behavior.

(list-windows #&key only except) 

This works like list-all-windows but allows you to specify additional
conditions on the windows returned. The #:only and #:except keyword
parameters may be specified to achieve this. Either should be followed
by a predicate or list of predicates. The windows returned are those
that satisfy all of the #:only predicates but none of the #:except
predicates. 

(winlist-skip)
(winlist-hit)
(winlist-skip?)

(show-window-list-menu #&key only except proc show-geometry)

This procedure shows a menu that lists the title of every suitable
window, and takes an action on the appropriate window if one is
selected. Here is the meaning of the keywords:

#:only - as above with list-windows; show only those windows that 
         satisfy the predicate or predictes given.
#:except - as above with list-windows; show only those windows that 
         do not satisfy the predicate or predictes given.
#:proc - apply this procedure to the window selected to the menu.
         defaults to window-list-proc.
#:show-geometry - If #t, will show the window geometry in addition to
                  titles. Defaults to #f.

(circulate-skip #&optional w)
(circulate-hit #&optional w)
(circulate-skip? #&optional w)
(circulate-skip-icon #&optional w)
(circulate-hit-icon #&optional w)
(circulate-skip-icon? #&optional w)
(should-circulate-skip? #&optional w)

(next-window #&key window only except proc)
(prev-window #&key window only except proc)

These procedures do something useful to the next or previous window in
the window list. They are most useful for implementing circulation of
the window list with the keyboard. Here is the meaning of the keywords:

#:window - start going forward or back in the window list from the 
	   specified window; defaults to the current window context.
#:only - as above with list-windows; show only those windows that 
         satisfy the predicate or predictes given.
#:except - as above with list-windows; show only those windows that 
         do not satisfy the predicate or predictes given.
#:proc - apply this procedure to the window selected to the menu.
         defaults to window-list-proc.


This module also adds these style options:

#:winlist-skip - skip this window in the window list menu
#:circulate-skip - #t/#f, skip this window when circulating with 
                   next-window or prev-window, or not.
#:circulate-skip-icon - #t/#f, skip this window when circulating with 
                   	next-window or prev-window, or not.


MODULE (app scwm wininfo)

This module provides additional predicates and generally informative
procedures for finding out stuff about windows.

(on-desk? n #&optional w)

((on-desk-n? n) #&optional w)

(on-current-desk? #&optional w)

(in-viewport-any-desk? #&optional w)

(visible? #&optional w)

(geometry-string #&optional w)

(wildcard-matcher wildcard #&key full-regexp regexp-oprions) 
Returns a procedure that takes one optional window argument (which
defaults to the current window context) and which will determine

(wildcard-match? wildcard #&optional w)


MODULE (app scwm optargs)

This module provides the interface for optional and keyword arguments
used by the other modules. It does not rely on any scwm-specific
functionality and can be used by any Guile script - in theory. I do
not reccomend using it in random programs because Guile will probably
have its own interface for optional and keyword arguments to Scheme
procedures some day. For this reason, the only complete documentation
is in the file optargs.scm itself. If you really want procedures with
optional or keyword arguments, take a look at some of the scheme
modules to see how it's done.


MODULE (app scwm style)

Styles let you specify how the look and feel of given windows starts
out. Most of the styles (those dealing with initial placement and
windowmanager hints) can also be set with interactive procedures. In
some cases,

(make-style . args)

This creates a style that can be used with the #:use-style option of
the style commands. It's really just a cons cell but it's poor to
depend on that. The arguments can be any of the options accepted by
the window-style command (see below).

(style-one-window w . args)

This applies a style to a single window. The arguments can be any of
the options accepted by the window-style command (see below).

(window-style condition . args)

This establishes a style that is applied to current and future
windows, much like the fvwm Style command. condition can be a
predicate that takes a window as an argument in which case all current
and future windows that satisfy the predicate will be styled; a
string, in which case all present and future windows that
wildcard-match the string (see wildcard-match above) will be styled;
or #t, in which case all future and present windows will be matched.
Of course, "*" has the same effect as #t, and is even special-cased to
be equally efficient, so the choice between these is a matter of
style. The remaining args are keywords alternating with values. The
available keywords can be extended by the user, but many standard ones
are defined. Styles defined by window-style are applied to new windows
in the order in which they are defined. Also, unlike most procedures
that take keyword options, the same key may be specified more than
once. The keys are processed in order, so the last one of a
conflicting pair is the one that will take effect.

(add-window-style-option key handler)
(add-boolean-style-option key t-handler f-handler)
(add-window-hint-option key handler)
(add-boolean-hint-option key t-handler f-handler)

These procedures let you define your own style options. The following
style options are predefined:

#:border-width - the number given will be used as the width of the window's
                 border - a small or 0 border-width, possible combined with
                 #:no-titlebar or #:plain-border can make "utility" windows
                 that you don't want to move around or resize very much 
                 relatively unobtrusive.

#:background - specify a color or string

#:bg - synonym for #:background

#:foreground - specify a color or string that will be used as the forground
               color of windows using this style.

#:fg - synonym for #:foreground

#:focus - sets the window's focus style, 'click, 'mouse, 'sloppy or 'none.

#:plain-border - if #t, makes the window have a plain border with no resize 
                 handles in the corner - like NoHandles

#:icon-title - sets the title of the window's icon to the specified string.

#:icon-box - a list of four numbers represents the x, y, width and height
             parameters of the icon box used for this window.

#:sticky-icon - #t/#f makes the window's icon (only) sticky or not.

#:start-iconified - #t/#f, makes the window start iconified or not.

#:kept-on-top - if #t, makes the window start as if keep-on-top had been 
		called on it, in other words, it stays on top, 

#:sticky - #t or #f, determines if the window starts sticky or not.

#:no-titlebar - #t/#f, makes the window lack or have a titlebar 
                respectively.


#:mwm-buttons - use mwm buttons - particular buttons should have their 
                beveling inverted when the window is maximized. This does
                not currently work.

#:mwm-border - #t or #f, determines if the border is mwm style or not.
               An mwm-style border has shallower insets than a normal one.

#:icon - #t, #f or a string that specifies an icon. If #f, the window will 
         have no icon. If #t, it will have one, but what it will be is
         unspecified. If a string, the bitmap or pixmap specified will be
         used as the icon.

#:mini-icon - #t or #f or a string that specifies a mini-icon. As above.

#:random-placement - if #t, windows with this style will always be placed
                     non-interactively, otherwise they will be sometimes
                     placed interactively if the placement algorithms fail.

#:smart-placement - if #t, windows with this style will be placed in an
                    empty place on the screen if they'd require user
                    interaction to place, if no such place is found they
                    are placed according to the value of smart-placement.

#:button - specifies that the button identified by the given number will
           be drawn for the window. Currently doesn't really work very well.

#:no-button - specifies that the button identified by the given number will
              not be drawn for the window. Currently doesn't really work very 
              well.

#:hint-override - if mwm-function hints are used, this

#:decorate-transient - #t or #f, decorate transient windows or not.

#:mwm-decor-hint - #t or #f, follow mwm decoration hints or not.

#:mwm-func-hint #t or #f, follow mwm function hints or not.

#:PPosition-hint - #t/#f, use the PPosition hint or not.

#:OL-decor-hint - #t/#f, use the OpenLook window manager hints or not.

#:start-on-desk - makes the window start on the specified desk. If #f, it
                  can start on any desk.

#:skip-mapping - #t or #f, change to the windows's desk while it is mapping
                 or not.

#:lenience - #t or #f; if #t, ignore window manager hints that say the window
             should never get the input focus, otherwise obey them.

#:use-style - use a style created with make-style.

;; use-decor not implemented for now

Here are some extra style options not available in fvwm:

#:start-maximized - takes #f or a list of two numbers. In the former case,
                    the window does not start maximized, in the latter
                    case it is maximized horizontally and/or vertically as
                    specified by the numbers.

#:start-lowered - #t or #f - sick of your windows starting on top of 
                  everything? Make them start out lowered with this handy 
                  option.

#:start-window-shaded - #t or #f, make the window start window-shaded (as per
                        window-shade) or not.

#:other-proc - lets you specify an additional procedure to apply to the window
               after it is created.

#:other-hint-proc - lets you specify an additional procedure to apply to the
                    window when hints are being processed.



MODULE (app scwm decor)

(call-with-decor decor thunk)
macro (with-decor decor . body)

Adds #:use-decor style option


MODULE (app scwm face)

(title-style . args)
(border-style . args)
(button-style num . args)


MODULE (app scwm fvwm-compat)

(fvwm-exec-use-shell #&optional shell)
(fvwm-exec command)
(fvwm-none thunk #&key only except)
(fvwm-pipe-read command)
(fvwm-nop . args)

