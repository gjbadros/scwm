

SCWM Scheme function documentation :

The scwm configuration file is a Guile Scheme program. All of the
usual Guile procedures are available. In addition, the following
windowmanager-sepcific procedures have been implemented. See the
sample system.scwmrc file for examples.

Documentation style:

A procedure documented as 
(foo BAR BAZ #&optional QUUX XYZZY . ARGS) 

is called foo and has required arguments BAR and BAZ, optional
arguments QUUX and XYZZY, and accepts any variable number of arguments
beyond that. All the specifications follow this pattern.


FONTS:

(load-font FONTNAME) 

This loads a font specified by the string FONTNAME and returns a font
object. All proocedures which expect a font can take either a font
object or a string specifier (in which case they automatically call
load-font themselves) but it you want to use a font many times is
more efficient to do something like :
(define helvetica 
  (load-font "-adobe-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))


(font? OBJ)
Returns #t if OBJ is a font object, else #f.

(set-icon-font! FONT)
(set-window-font! FONT)
(set-menu-font! FONT)

These set the icon, titlebar and menu fonts respectively.


COLORS:

(load-color COLORNAME)

load-color basically works like load-font, except 

(color? OBJ)
Returns #t if OBJ is a color object, else #f.

(set-hilight-colors! #&optional FG BG)

Sets the hilight foreground and background colors. If you pass #f for
either one, it is left unchanged.

(set-menu-colors! #&optional FG BG STIPPLE)

This sets the menu foreground, background and stipple colors. As
above, #f indicates that the relevant color should not be changed.


BINDINGS:

(bind-key CONTEXTS KEY-SPECIFIER PROC)

This establishes a key binding. CONTEXTS specifies the context(s) in
which it will be in effect. It can be one of the following symbols or
a list of several:

window, title, icon, root, frame, sidebar, button-1, button-2,
button-3, button-4, button-5, button-6, button-7, button-8, button-9,
button-10, all

Using 'all as the context includes all of the others.

The key to bind is specified as a string, sort of emacs-style. Some
examples: 

"x","F1","C-x","M-space","C-M-a"

Basically, you give a characer or a keysym prefixed by any combination
of "C-", "M-" and "S-" representing Control, Meta and Shift
respectively. Other prefixes that emacs understands will be
implemented as soon as I understand what they do in emacs.

The proc is a Scheme procedure of no arguments. If the key binding is
invoked from within anywhere but the root window, the current window
context is set to the window it was invoked from. Window contexts are
explained in the section on window operations.


(bind-mouse CONTEXTS BUTTON-SPECIFIER PROC)

Works much like bind-key above, but binds to a mouse action. In
addition to possibly setting the window context, it also sets the
current mouse event type so that the type of mouse event can be
distiguished from the procedure. This is explained in 
 Mouse button specifiers are either
numbers or strings that consist of a number with optional prefixes
specifying modifier keys. Here are some valid mouse specifiers


(mouse-event-type)

If called from code that was invoked by a mouse binding, it returns
the type of mouse event, one of 'motion 'click 'one-and-a-half-clicks
or 'double-click. This can be used in conjunction with Scheme's case
or cond special forms to do different things based on the type of
event. This functionality may go away in favor of being able to bind
any kind of mouse event type separately.


MISCELLANEOUS SETTINGS:

(set-menu-mwm-style! BOOL)

Determines if menus are MWM style or FVWM style.

(set-xor-value! INT)

Sets the XOR value used for rubber-banding windows.

(set-title-height! INT)

Sets the height of the title-bar.

(set-title-justify! SYM)

Sets the title-bar justification. The symbol must be one of 'left,
'right or 'center.

(set-click-time! INT)

Sets the maximum time that must elapse after a mouse can be pressed
and not yet released that will still be interpreted as a click and not
a motion. The time is given in milliseconds. The default is 150.

(set-colormap-focus! SYM)
Sets the colormap focus style, either 'focus or 'mouse. In the first
case, the window with keyboard focus has the colormap focus, in the
other case, the colormap focus follows the mouse even if the keyboard
focus doesn't.

(set-opaque-move-size! INT)
Sets the largest window size that will be moved opaquely rather than
with rubber-banding, as percentage of screen size. 0 will make all
windows rubber-band when they move, while 100 will make all windows
move as solid. The default


MISCELLANEOUS OPERATIONS:

(refresh)

Refreshes the whole screen.

(get-pointer-position)

Returns a list of the current x and y coordinates of the mouse cursor.

(move-pointer-to X Y)

Moves the pointer to the absolute position X,Y.

(recapture)

(restart NEW-WM)

(wait-for-window NAME)

WINDOWS: 


(window? OBJ)
Returns #t if OBJ is a window object, else #f.

(get-window) 

Retrieves the current window context and returns the window object
representing it. If no window context is set, it lets the user select
a window by ccalling select-window. However, select-window is not
really implemented yet so it will actually return #f in this case.

(select-window) [not fully implemented]


WINDOW OPERATIONS:

For all of these, the optional window argument defaults to the current
window context. This makes it convenient to bind window operations to
key or mouse events. It also means that in most cases, you won't need
to use the optional W argument, but sometimes it is needed. 

(focus #&optional W)
Give W the keyboard focus.

(warp-to-window #&optional W)
Warp the mouse pointer to the window W.

(delete-window #&optional W)
Delete W, in other words, close it politely. This may not always work.

(destroy-window #&optional W) 
Destroy W, in other words, close it rudely. This always works, but
will not give the application the chance to do special shutdown
actions, like asking for confirmation.

(window-deletable? #&optional W)
Returns #t if delete-window will work on W, else #f.

(lower-window #&optional W)
Lowers W to the bottom of the window stack.

(raise-window #&optional W)
Raises W to the top of the window stack.

(raised? #&optional W)
Returns #t if W is currently raised, else #f.

(iconify #&optional W) 
Iconifies window W.

(deiconify #&optional W) 
Deiconifies window W.

(iconified? #&optional W)
Determines if W is iconified.

(stick #&optional W)
"Sticks" window W. This makes it remain in the same position on the screen
when desks or pages are switched.

(unstick #&optional W)
Reverses the effects of "stick."

(sticky? #&optional W)
Determines if a window is currently "sticky."

(window-shade #&optional W)
Rolls up the window into just a title bar, like a window shade.

(un-window-shade #&optional W)
Reverses the effect of window-shade.

(window-shaded? #&optional W)
Determines if the window is currently shaded.

(move-to X Y #&optional W)
Moves the window to X,Y on the current screen.

(interactive-move #&optional W) 
Begins an interactive move operation. The user can adjust the position
of the window with the mouse or arrow keys.

(resize-to X Y #&optional W)
Resizes the window to X by Y. 

(interactive-resize #&optional W) 
Begins an interactive resize operation. The user can adjust the
position of the window with the mosue or arrow keys.

(refresh-window #&optional W)
Refreshes the window, ensuring that its contents and decorations  are
up to date and properly displayed.

(move-window-to-desk DESK #&optional W)
Moves the window to a new desk, specified by an integer.

MENUS:

(menu? OBJ)
Returns #t if OBJ is a menu object, else #f.

(make-menu TITLE [(list NAME PROC-OR-MENU)|'title|'separator] ...)

Creates a menu object. The first argument is a string that is the menu
title, however, the title is not necessarily displayed unless so
specified. Arguments are successively one of 'title, 'separator, or a
list of a string and a either procedure of no arguments or another
menu object. Respectively, these result in a title, a separator bar,
or an entry that will call the procedure when selected, or display the
menu as a submenu. It is reccomended that an actual menu object be
specified for submenus rather than a procedure which uses popup to
display the menu, because 


(popup MENU #&optional STICK?)

Pops up the menu. If stick is specified, it determines if the menu
stays up when the mouse is released, assuming it was started in
response to a mouse click. The default is #f.


PATHS:

(set-icon-path! PATH)
(set-pixmap-path! PATH)


VIRTUAL DESKTOP:

(set-current-desk! DESK)
(set-viewport-position! X Y)
(set-edge-scroll! X Y)
(set-edge-wrap! X Y)
(set-edge-resistance! SCROLL-RESISTANCE MOVE-RESISTANCE)
(set-desk-size! X Y)
(display-size)
(desk-size)
(viewport-position)
(current-desk)







PROCEDURES IN SCHEME:

These procedures are written and scheme and are there to provide a
friendlier interface to the builtins.

These two are always available because they are defined in the default
rc code that's built into the binary. They do not accept an optional
window argument since they are meant to be used with mouse or key
bindings and depend on the mouse event type.

(resize-or-raise)
Always raise the window, resize it interactively if the mouse is
moved, and lower on a double-click.

(move-or-raise)
Always raise the window, move it interactively if the mouse is
moved, and lower on a double-click.


The rest of the operations are available in modules. Each set is
prefaced with the proper module name.


MODULE (app scwm base)

(%x x) 

x is treated as a precentage of the horizontal screen size and the
proper value in pixels is returned. This is useful for writing rc
files that don't depend too much on the display size for reasonable
placement.

(%y y)

Kust like %x, but for the vertical direction.

(execute command) 

Executes a shell command as a separate process, for example (execute
"xterm") or (execute "cat ~/some-file | grep pattern") or whatever.


(set-menu-foreground! fg)
(set-menu-background! bg)
(set-menu-stipple! st)

These set only one of the menu color components. They may go away
since the menu-style interface is more useful.


(move-pointer x y) 
Moves the mouse pointer relative to the current position
(move-pointer-to moves it absolutely).

(menu-style #&key fg foreground bg background stipple font mwm mwm-style) 

This is a general-purpose interface for setting various things that
relate to menus. It is called with keyword-value pairs like so:
(menu-style #:fg "red" #:background "black" #:mwm #t)

This example sets the foreground to red, the background to black, and
the mwm-style to true. The keywords available are:

#:fg or #:foreground - foreground color
#:bg or #:background - background color
#:stipple - stipple color
#:font - font
#:mwm or #:mwm-style - mwm style. If true, menus are "mwm style", else they
are "fvwm style".

(title-style #&key font height justify)

This is a similar interface to the above. The available keywords are

#:font - the titlebar font
#:height - the titlebar height
#:justify - the justification - 'left, 'right or 'center.

I'd like to eventually have more option-style interfaces like this,
which collect all the different style options for something into one
convenient procedure.


MODULE (app scwm winops)

This is a collection of extra window operations. Like the standard
window operations, they default to the current window context if the
window is not specified.

(define*-public ((make-toggling-winop pred neg pos) 
		 #&optional W)

This can be used to define toggling window operations easily. you pass
a predicate which determines if the window has been affected, then a
procedure which undoes the operation, then one which does it, and a
procedure is returned which will do a toggling version of the effect.


(close-window #&optional W)

Delete the window if possible, otherwise destroy it.

(toggle-raise #&optional W)
Raise the window if it is not already on top. If it is, lower it.

(toggle-iconify #&optional W)
Iconify the window if it isn't already, else deiconify it.

(toggle-stick #&optional W)
Stick the window if it isn't already, else unstick it.

(toggle-window-shade #&optional W)
window-shade the window if it isn't already, else un-window-shade it.

(maximize nw nh #&optional W)
Maximizes the window to size nw by nh. If either of nw or nh is 0, the
size in that direction will not be changed. Also, a window maximized
vertically will be moved to the top edge of the display, and a window
maximized horizontally will be moved to the left edge.

(maximized? #&optional W)
Determines if the window is maximized.

(unmaximize #&optional W)
Unmaximizes the window if it is maximized, restoring it to its size
and position previous to any maximize operations.

(toggle-maximize nw nh #&optional W)
A toggling version of maximize.

(print-window #&optional W)
Prints a screen dump of the selected window.


MODULE (app scwm winlist)

This module includes procedures for manipulating the window list.


(default-winlist-proc #&optional w)
This is the normal default window list procedure. It deiconifies,
focuses and raises the window, then warps the pointer to a convenient
point inside it.

window-list-proc

This varibale holds the procedure that will be applied by default to
the window selected from the window list menu. It is normally
default-winlist-proc, but you can set! it to something else to make
that the default behavior.

(list-windows #&key only except) 

This works like list-all-windows but allows you to specify additional
conditions on the windows returned. The #:only and #:except keyword
parameters may be specified to achieve this. Either should be followed
by a predicate or list of predicates. The windows returned are those
that satisfy all of the #:only predicates but none of the #:except
predicates. 


(show-window-list-menu #&key only except proc show-geometry)

This procedure shows a menu that lists the title of every suitable
window, and takes an action on the appropriate window if one is
selected. Here is the meaning of the keywords:

#:only - as above with list-windows; show only those windows that 
         satisfy the predicate or predictes given.
#:except - as above with list-windows; show only those windows that 
         do not satisfy the predicate or predictes given.
#:proc - apply this procedure to the window selected to the menu.
         defaults to window-list-proc.
#:show-geometry - If #t, will show the window geometry in addition to
                  titles. Defaults to #f.


(next-window #&key window only except proc)
(prev-window #&key window only except proc)

These procedures do something useful to the next or previous window in
the window list. They are most useful for implementing circulation of
the window list with the keyboard. Here is the meaning of the keywords:

#:window - start going forward or back in the window list from the 
	   specified window; defaults to the current window context.
#:only - as above with list-windows; show only those windows that 
         satisfy the predicate or predictes given.
#:except - as above with list-windows; show only those windows that 
         do not satisfy the predicate or predictes given.
#:proc - apply this procedure to the window selected to the menu.
         defaults to window-list-proc.



MODULE (app scwm wininfo)

This module provides additional predicates and generally informative
procedures for finding out stuff about windows.

(on-desk? n #&optional (w (get-window)))

((on-desk-n? n) #&optional (w (get-window)))

(on-current-desk? #&optional (w (get-window)))

(in-viewport-any-desk? #&optional (w (get-window)))

(visible? #&optional (w (get-window)))

(geometry-string #&optional w)




MODULE (app scwm optargs)

This module provides the interface for optional and keyword arguments
used by the other modules.
