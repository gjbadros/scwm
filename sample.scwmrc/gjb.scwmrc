;;-------------------------------;;
;; import the scwm modules       ;;

(use-modules (app scwm base)
	     (app scwm winops)
	     (app scwm winlist)
	     (app scwm wininfo)
             (app scwm style)
	     (app scwm face))


(define HOME (getenv "HOME"))
(define USER (getenv "USER"))
(define xterm-user-shell-options "-e start-zsh")
(define xterm-other-host-use-local-xterm #t)
(define mail-spool-dir (string-append "/var/spool/mail/" USER))


(define user-image-path (string-append HOME "/pixmaps:" HOME "/bitmaps"))

(define want-close-button #t) ;; was #f

;;-------------------------------;;
;; set some basic styles info    ;;

(define (vertical-toggle-maximize)
  (toggle-maximize 0 (%y 100)))

(define (horizontal-toggle-maximize)
  (toggle-maximize (%x 100) 0))

(define (both-toggle-maximize)
  (toggle-maximize (%x 100) (%y 100)))

(define (vertical-toggle-maximize-partial)
  (toggle-maximize 0 (%y 95)))

(define font12
  (load-font "-adobe-helvetica-bold-r-*-*-12-*-*-*-*-*-*-*"))
(define font14 
  (load-font "-adobe-helvetica-bold-r-*-*-14-*-*-*-*-*-*-*"))
(define window-font
  (load-font "*helvetica*bold-r*12*"))
(define menu-font
  (load-font "*helvetica*medium-r*12*"))
(define icon-font
  (load-font "fixed"))

;(define (menu-item name pixmap action)
;  (list (if pixmap (string-append name "%mini-" pixmap ".xpm%") name) action))

;;(menu-style #:fg "white" #:bg "blueviolet" #:stipple "blue" 
;;	    #:font font14 #:mwm #f)
(menu-style #:fg "black" #:bg "grey76" #:stipple "grey35" 
	    #:font menu-font #:mwm #f)

;;(set-click-time! 150)
;;(set-color-map-focus! 'follows-mouse)
;;(set-desktop-size! 3 3)

;;; FIXGJB: should be a function returning whether it should do opaque
;;; move or an integer for the percent (server/net/cpu load might
;;; influence whether you want to do an opaque move, e.g.)

;;(set-opaque-move-size! 30) 
;;(set-edge-resistance! 500 10)
;;(set-edge-scroll! 100 100)


(title-style #:font font12 #:justify 'left #:relief 'raised)

(set-icon-font! font12)
(set-rubber-band-mask! 255)  

;;-------------------------------;;
;; set some paths                ;;
;;

(set-image-path! (string-append user-image-path 
				 ":/usr/X11/include/X11/bitmaps:\
/usr/local/X11/include/X11/pixmaps:/usr/local/lib/icons:\
/uns/share/include/X11/pixmaps:/uns/share/include/X11/bitmaps:\
/usr/lib/icons:/usr/X11/include/X11/pixmaps:/usr/X11/lib/X11/mini-icons"))

(define pic-system-button
  (make-image "mini-sys3d-full.xpm"))

(define pic-xterm-mini
  (make-image "mini-term.xpm"))

(define pic-unknown
  (make-image "unknown1.xpm"))


;;-------------------------------;;
;; set some window styles        ;;

;;; MSFIX: I don't like the ordering dependence on the
;;; window-style... I think that will go away when using
;;; the XClass and/or Instance name tests, which I'd prefer
;;; anyway...
(window-style "*" 
	      #:fg "black" #:bg "grey76" 
	      #:icon pic-unknown
;	      #:icon #f        ;; MS - specify #f to not get an icon.
	      #:icon-box (list (x- 70) 1 69 (y- 141))
	      #:border-width 4 ;; MS borderwidth of 4 looks slightly better
	                       ;; to my eye than 3.
	      #:focus 'mouse

;	      #:plain-border #t ;; replaces handle-width
				;; MS no, it replaces no-handles, plus
	                        ;; it doesn't work right now.
	      #:sticky-icon #t
	      #:random-placement #t #:smart-placement #t
	      #:mwm-func-hint #t #:mwm-decor-hint #t
	      #:int-override #t #:decorate-transient #t
	      #:PPosition-hint #f
	      #:mini-icon pic-xterm-mini)

;; FIXGJB: make-face's style of argument passing
;; is different from the window-style method; I imagine
;; MS has a wrapper planned for this (MSFIX)

(border-style #:hidden-handles #t #:no-inset #t)

;;; I'm not changing these for now to use the new style
;;; because of the way add-left-button and add-right-button work and
;;; such; I think in general, though, setting the button appearance
;;; should be more separated from setting its function. Will look
;;; over this more. --MS
;;; MSFIX: I think actions and conceptual appearance should go together
;;; but that conceptual appearance and actual appearance should be separated.
;;; Now that pixmaps are real objects, I get this by making, e.g.,
;;; `sticky-button-face' and `(add-left-button sticky-button-face toggle-stick)'
;;; I never want to say, `the third button from the right should do this action'.
;;; Ideally, buttons should have some identifier which can be tested by the
;;; event handling code for the callbacks

(define mini-icon-button-face 
  (make-face '((relief flat))
	     '((pixmap mini-program-icon))))

;; Can use strings as arg to pixmap
(define sticky-button-face
  (make-face '((relief flat))
	     '((pixmap "mini-hbars-full.xpm"))))

;; For testing
;;(set-button-face! 3 sticky-button-face)


;; But can also use a (make-image  "file.xpm")
(define sysutils-button-face
  (make-face '((relief flat))
	     '((pixmap "mini-lightbolt-full.xpm"))))


(define close-button-face 
  (make-face '((relief flat))
	     '((pixmap  "mini-stylized-x-full.xpm"))))


(define tall-maximize-button-face (make-face '((relief flat))
					     '((pixmap "mini-exp-windows-full.xpm"))))


(define iconify-button-face (make-face '((relief flat))
				       '((pixmap "mini-shrink-windows-full.xpm"))))



(define left-button-number 1)
(define right-button-number 2)

;;(set-button-face! 1 mini-icon-button-face)

(define (add-left-button button-face hook)
  (set-button-face! left-button-number button-face)
  (bind-mouse (string->symbol 
	       (string-append "button-" 
			      (number->string left-button-number)))
	      1 hook)
  (set! left-button-number (+ 2 left-button-number)))


(define (add-right-button button-face hook)
  (set-button-face! right-button-number button-face)
  (bind-mouse (string->symbol 
	       (string-append "button-" 
			      (number->string right-button-number)))
	      1 hook)
  (set! right-button-number (+ 2 right-button-number)))

;; window buttons
;;(bind-mouse 'button-1 1 popup-small-ops)
;;(bind-mouse 'button-2 1 vertical-toggle-maximize)
;;(bind-mouse 'button-4 1 iconify)

;;(add-left-button system-button-face (lambda () (popup-small-ops)))
(add-left-button mini-icon-button-face (lambda () (popup-small-ops)))

;; MS: I presume this is the desired efffect.
;; random thought: A nice extension would be buttons that change
;; appearance with given window properties. This would be an extension of
;; the fvwm2 "MWMButton" concept whereby a button reverses its vector 
;; pattern when the window is maximized. It should be much more general, 
;; of course.
(add-left-button sticky-button-face toggle-stick)

(add-left-button sysutils-button-face (lambda () (display "sysutils")))

(if want-close-button
    (add-right-button close-button-face close-window))

(add-right-button tall-maximize-button-face
		  (lambda () (vertical-toggle-maximize)))
(add-right-button iconify-button-face
		  (lambda () (iconify)))

;;(set-button-face! 1 mini-icon-button-face)
;;(set-button-face! 1 tall-maximize-button-face)

;; (plain-border (get-window)) fixes the display problem for the selected window
;; something must not be initialized correctly

(set-hilight-colors! "white" "navyblue")

(define desk-widget
  (make-style #:plain-border #t #:sticky #t #:winlist-skip #t
	      #:border-width 3 #:circulate-skip #t #:focus 'none))

;; Inherit above style options and specialize
(define desk-widget-on-top
  (make-style #:use-style desk-widget #:stays-on-top #t))

;; NOTE: you can use a string or a (make-image "filename.xpm")
;; after #:icon and #:mini-icon
;; MSFIX: important! window-style's argument 
(window-style "zwgc" #:use-style desk-widget-on-top)
(window-style "*lock" #:use-style desk-widget)
(window-style "xload" #:no-title #t #:use-style desk-widget)
(window-style "xscreensaver" #:no-title #t #:use-style desk-widget)
(window-style "xbiff" #:no-title #t #:use-style desk-widget-on-top
	      #:mini-icon "mini-xbiff.xpm")
(window-style "xcalc" #:icon "xcalc.xpm"
	              #:mini-icon "mini-calc.xpm")
(window-style "xman" #:icon "xman.xpm")
(window-style "xmag" #:icon "mag_glass.xpm")
(window-style "XTerm" #:mini-icon pic-xterm-mini
	              #:icon "xterm.xpm")
(window-style "Emacs" #:mini-icon "mini-edit.xpm"
	              #:icon "TextEditor.xpm")

;;-------------------------------;;
;; define some useful menus      ;;

(define menu-window-ops
  (make-menu "Window Ops"
	     (menu-title)
	     (menu-item "&Move" #:left-pixmap "mini-move.xpm" 
			#:action interactive-move)
	     (menu-item "&Resize" #:left-pixmap "mini-resize.xpm" 
			#:action interactive-resize)
	     (menu-item "R&aise" #:left-pixmap "mini-raise.xpm" 
			#:action raise-window)
	     (menu-item "&Lower" #:left-pixmap "mini-lower.xpm" 
			#:action lower-window)
	     (menu-item "&Iconify/Restore" #:left-pixmap "mini-iconify.xpm" 
			#:action toggle-iconify)
	     (menu-item "&Stick/Unstick" #:left-pixmap "mini-stick.xpm" 
			#:action toggle-stick)
	     (menu-item "Ma&ximize/Reset" #:action both-toggle-maximize)
	     (menu-item "Ma&ximize &Tall/Reset"
			"maxtall" #:action vertical-toggle-maximize)
	     (menu-item "Maximize &Wide/Reset"
			"maxwide" #:action horizontal-toggle-maximize)
	     (menu-item "S&hade/Reset" #:action toggle-window-shade)
	     (menu-separator)
	     (menu-item "Keep-&on-top/Reset" #:action toggle-on-top)
	     (menu-item "&Print" #:action print-window)
	     (menu-separator)
	     (menu-item "&Delete" #:action delete-window)
	     (menu-item "&Close" #:left-pixmap "mini-cross.xpm" 
			#:action close-window)
	     (menu-item "&Kill" #:left-pixmap "mini-bomb.xpm" 
			#:action destroy-window)
	     (menu-separator)
	     (menu-item "Switch to..." #:action
			(lambda () 
			  (show-window-list-menu #:show-geometry #t)))
	     (menu-item "Re&fresh Screen" #:left-pixmap "mini-ray.xpm" 
			#:action refresh)))

;;(window-shade (get-window) #t)
;;(un-window-shade (get-window) #t)

(define (wiggle-window)
  (let ((w (get-window)))
    (window-shade w #t)
    (un-window-shade w #t)))

;;FIXGJB:
(define (scwm-help)
  (display "Need to write scwm-help\n"))

;;FIXGJB:
(define (scwm-about-message)
  (display "Need to write scwm-about-message\n"))


(define (start-xterm)
  (execute (string-append "color-xterm " xterm-user-shell-options)))

(define (exec-xlock)
  (execute "xlock -nice -16 -mode blank"))

(define (tell-workman command)
  (execute (string-append "workman -s " command)))

(define quit-verify
  (make-menu "Really quit scwm?"
	     (menu-title)
	     (menu-item "Yes" #:action quit)
	     (menu-item "No" #:action noop)
	     (menu-separator)
	     (menu-item "Restart scwm" #:action
			(lambda () (restart "scwm")))))


(define use-complete-host-menu #t)

;;; FIXGJB introduce syntax which gives the popup-menu-root-start closure after
;;; defining a menu
(define menu-root-start
;  (make-menu "RootStart%linux-menu.xpm@^blue^" "Start %mini-exp.xpm%"
  (make-menu "Start %mini-exp.xpm%"
	     (menu-title)
	     (menu-item "&New shell" #:left-pixmap "mini-sh1.xpm" 
			#:action start-xterm)
	     (menu-item "&Applications" #:left-pixmap "mini-x2.xpm" 
			#:action (lambda () 
					       (popup menu-applications)))
	     (menu-item "&Utilities" #:left-pixmap "mini-hammer.xpm" 
			#:action (lambda ()
						(popup menu-utilities)))
	     (menu-item "&Multimedia" #:left-pixmap "mini-audiovol.xpm" 
			#:action (lambda ()
						   (popup menu-multimedia)))
	     (menu-item "&Games" #:left-pixmap "mini-happy.xpm" 
			#:action (lambda ()
					   (popup menu-games)))
	     (menu-separator)
	     (menu-item "H&osts" #:left-pixmap "mini-windows.xpm" 
			#:action (lambda ()
					     (popup menu-hosts)))
	     (if use-complete-host-menu
		 (menu-item "O&ther Hosts" #:action 
			    (lambda ()
			      (popup menu-otherhosts))))
	     (menu-item "&System Utilities" #:left-pixmap "mini-connect.xpm" 
			#:action (lambda ()
				   (popup menu-system-utilities)))
	     
	     ;; MS - use the menu object rather than a popup closure when 
	     ;; possible to get correct submenu semantics
	     (menu-item "&Window Operations" #:left-pixmap "mini-windows.xpm" 
			#:action menu-window-ops)
	     (menu-item "&Preferences" #:left-pixmap "mini-prefs.xpm" 
			#:action (lambda ()
				   (popup menu-preferences)))
	     (menu-separator)
	     (menu-item "S&creensaver" #:left-pixmap "mini-display.xpm" 
			#:action (lambda ()
				   (popup menu-screensaver)))
	     (menu-item "&Lock Screen" #:left-pixmap "mini-lock.xpm" 
			#:action (lambda ()
				   (exec-xlock)))
	     (menu-separator)
	     (menu-item "A&bout ScwmTNL" #:left-pixmap "mini-exclam.xpm" 
			#:action (lambda ()
				   (scwm-about-message)))
	     (menu-item "&Help ScwmTNL" #:left-pixmap "mini-question.xpm" 
			#:action (lambda ()
				   (scwm-help)))
	     (menu-item "E&xit Scwm" #:left-pixmap "mini-stop.xpm" 
			#:action quit-verify)))


(define (popup-menu-root-start)
  (popup menu-root-start))


(define (popup-ops)
  (popup menu-window-ops))

(define menu-desk 
  (make-menu "Desks"
	     (menu-title)
	     (menu-item "Desk 1" #:action (lambda () (set-current-desk! 0)))
	     (menu-item "Desk 2" #:action (lambda () (set-current-desk! 1)))
	     (menu-item "Desk 3" #:action (lambda () (set-current-desk! 2)))
	     (menu-item "Desk 4" #:action (lambda () (set-current-desk! 3)))))

(define menu-util 
  (make-menu "Utilities"
	     (menu-title)
	     (menu-item "xterm" #:left-pixmap "mini-term.xpm" 
			#:action (lambda () (execute "xterm")))
	     (menu-item "rxvt"
			#:action (lambda () (execute "rxvt")))
	     (menu-item "emacs" #:left-pixmap "mini-edit.xpm" 
			#:action (lambda () (execute "emacs")))
	     (menu-item "top" #:action (lambda () (execute "rxvt -T Top -n Top -e top")))
	     (menu-item "xcalc" #:action (lambda () (execute "xcalc")))
	     (menu-item "xmag" #:action (lambda () (execute "xmag")))
	     (menu-separator)
	     (menu-item "Desks" #:action menu-desk)
	     (menu-separator)
	     (menu-item "Exit scwm" #:action quit-verify)))

(define (popup-util)
  (popup menu-util))

(define (popup-root-start)
  (popup menu-root-start))

(define (make-small-window-ops-menu w)
  (make-menu "Window Ops Small"
	     (menu-item "&Move" #:left-pixmap "mini-move.xpm" 
			#:action interactive-move)
	     (menu-item "Re&size" #:left-pixmap "mini-resize.xpm" 
			#:action interactive-resize)
	     (menu-item (if (iconified? w)
			    "Unmi&nimize"
			    "Mi&nimize") #:left-pixmap "mini-iconify.xpm" 
			    #:action iconify)
	     (menu-item (if (maximized? w) 
			    "Unma&ximize" 
			    "Ma&ximize") #:action both-toggle-maximize)
	     (menu-separator)
	     (menu-item "More" 
			#:action 
			(make-menu 
			 "More"
			 (menu-item "&Raise" #:action raise-window)
			 (menu-item "&Lower" #:action lower-window)
			 (menu-item (if (sticky? w)
					"Un&stick"
					"&Stick") 
				    #:action toggle-stick)
			 (menu-item (if (window-shaded? w)
					"Unwindow-S&hade"
					"Window-S&hade")
				    #:action toggle-window-shade)
			 (menu-item (if (kept-on-top? w)
					"UnKeep On Top"
					"Keep On Top") 
				    #:action toggle-on-top)))
             (menu-separator)
	     (menu-item "Close" #:left-pixmap "mini-cross.xpm" 
			#:action close-window)
	     (menu-item "Destroy" #:left-pixmap "mini-bomb.xpm" 
			#:action destroy-window)))

(define (popup-small-ops)
  (popup (make-small-window-ops-menu (get-window))))


;; now set some mouse and key bindings ;;

(define (show-icon-list-menu)
  (show-window-list-menu #:only iconified?))


;; first our root menus
(bind-mouse 'root 1 popup-root-start)
(bind-mouse 'root 2 (lambda () 
		      (show-window-list-menu #:show-geometry #t)))
;;(bind-mouse 'root 3 popup-applications)
(bind-mouse 'root "M-3" (lambda () (popup menu-desk)))

;; operations on parts of the window
(bind-mouse '(frame sidebar) 2 popup-small-ops)
(bind-mouse 'frame 1 resize-or-raise)
(bind-mouse 'sidebar 1 move-or-raise)
(define (move-or-shade)
  (case (mouse-event-type)
    ((double-click) (toggle-window-shade-animated))
    (else (move-or-raise))))
(bind-mouse 'title 1 move-or-shade)
(bind-mouse 'title 2 lower-window)


;; key bindings for the menus
(bind-key 'all "M-S-F1" popup-util)
(bind-key 'all "M-S-F2" popup-ops)

;; in case of emergency, hit Control-Meta-Q
(bind-key 'all "C-M-S-q" quit)

;; some stuff for icons
(define (move-or-deiconify)
  (case (mouse-event-type)
    ((motion) (interactive-move))
    ((double-click) (deiconify))))

(bind-mouse 'icon 1 move-or-deiconify)
(bind-mouse 'icon 2 deiconify)

(bind-mouse 'all "C-S-M-1" toggle-raise)
(bind-mouse 'all "C-S-M-2" interactive-move)
(bind-mouse 'all "C-S-M-3" interactive-resize)

;; Just for test bind, unbind-mouse
;;(unbind-mouse 'all "C-S-Mouse1")
;;(unbind-mouse 'all "C-S-M-2")
;;(bind-mouse 'all "C-S-Mouse-1" show-icon-list-menu)

(define (interactive-move-window-with-focus)
  (let ((w (current-window-with-focus)))
    (and w (interactive-move w))))

(define (interactive-resize-window-with-focus)
  (let ((w (current-window-with-focus)))
    (and w (interactive-resize w))))

(define (interactive-move-window-with-pointer)
  (let ((w (current-window-with-pointer)))
    (and w (interactive-move w))))

(define (interactive-resize-window-with-pointer)
  (let ((w (current-window-with-pointer)))
    (and w (interactive-resize w))))

(bind-key 'all "C-S-F7" interactive-move-window-with-pointer)
(bind-key 'all "C-S-F8" interactive-resize-window-with-pointer)

;; rotate the current window with the keyboard
(bind-key 'all "M-S-Tab" 
	  (lambda ()
	    (next-window #:only visible? #:except iconified?)))

(define (key-mouse-moves modifiers pct-of-screen left down up right)
  (bind-key 'all (string-append modifiers "-" left) 
	    (lambda () (move-pointer (%x (- pct-of-screen)) 0)))
  (bind-key 'all (string-append modifiers "-" down) 
	    (lambda () (move-pointer 0 (%y pct-of-screen))))
  (bind-key 'all (string-append modifiers "-" up) 
	    (lambda () (move-pointer 0 (%y (- pct-of-screen)))))
  (bind-key 'all (string-append modifiers "-" right) 
	    (lambda () (move-pointer (%x pct-of-screen) 0))))

(define (key-viewport-moves modifiers pct-of-screen left down up right)
  (bind-key 'all (string-append modifiers "-" left) 
	    (lambda () (move-viewport (%x (- pct-of-screen)) 0)))
  (bind-key 'all (string-append modifiers "-" down) 
	    (lambda () (move-viewport 0 (%y pct-of-screen))))
  (bind-key 'all (string-append modifiers "-" up) 
	    (lambda () (move-viewport 0 (%y (- pct-of-screen)))))
  (bind-key 'all (string-append modifiers "-" right) 
	    (lambda () (move-viewport (%x pct-of-screen) 0))))

(key-mouse-moves "C-M-S" 5 "h" "j" "k" "l")
;; XInside's old X server steal C-M-h for prev virtual console, so use m too
(key-mouse-moves "C-M-S" 5 "m" "j" "k" "l")

(key-mouse-moves "C-M-S" 1 "y" "u" "i" "o")

(key-viewport-moves "C-M-S" 100 "Left" "Down" "Up" "Right")
;(key-viewport-moves "C-M-S" 10 "KP_4" "KP_2" "KP_8" "KP_6")

(bind-key 'all "C-M-S-r" refresh)
(bind-key 'all "C-M-S-5" recapture)
(bind-key 'all "C-M-S-x" (lambda () (start-xterm)))

(bind-key 'all "C-S-F1" popup-small-ops)
(bind-key 'all "C-S-F2" show-window-list-menu)

(define (float->integer x)
	 (inexact->exact x))

;; These are useful!
(define root-size-x (car (display-size)))
(define root-size-y (cadr (display-size)))

;; FIXGJB: where is setenv?
;;(setenv "height" (number->string root-size-x))
(putenv (string-append "height=" (number->string root-size-y)))
(putenv (string-append "width=" (number->string root-size-x)))
;; FIXGJB: PLANES? SCWM_DIR? SCWM_VERSION?  want these exported too

(define (percent-display x y)
  (list (%x x) (%y y)))

(bind-key 'all "C-S-Down" iconify)
;;(bind-key 'all "C-M-Return" raise-window)
(bind-key 'all "C-M-Return" toggle-raise)
(bind-key 'all "C-S-Up" vertical-toggle-maximize-partial)
(bind-key 'all "C-S-Right" horizontal-toggle-maximize)
(bind-key 'all "C-S-Left" both-toggle-maximize)
;; MS thinks (maximize (%x 0) (%y 95)) is easier to read than 
;; (apply maximize (percent-display 0 95)), but that's a matter of taste.
(bind-key 'all "C-S-Up" (lambda () (apply toggle-maximize (percent-display 0 95))))
(bind-key 'all "C-S-Right" (lambda () (apply toggle-maximize (percent-display 100 0))))
(bind-key 'all "C-S-Left" (lambda () (apply toggle-maximize (percent-display 100 95))))

;; See the binding for mouse button 2
;; to add geometry strings to this as well.
(bind-key 'all "C-S-Return" show-icon-list-menu)

(bind-key 'all "C-S-M-z" (lambda () (popup menu-root-start)))

(set-click-time! 150)

(define (animated-move-to x y)
  (let* ((w (get-window))
	 (size (window-size w))
	 (width (car size))
	 (height (cadr size))
	 (position (window-position w))
	 (oldx (car position))
	 (oldy (cadr position)))
    ;;; FIXGJB: is there a better way to correct for width, height, etc
    ;;; MS: perhaps we should make move-to take #f for either coordinate,
    ;;; which means don't move along that coord?
    (if (equal? x 'x) (set! x oldx))
    (if (equal? y 'y) (set! y oldy))
    ;; MS: see base.scm for x- and y-, which I think are a more genric
    ;; way to handle negative positions in the traditional X11 way.
    (if (< x 0) (set! x (- root-size-x (abs x) width)))
    (if (< y 0) (set! y (- root-size-y (abs y) height)))
    (raise-window w)
    (move-to x y w 'animated 'move-pointer-too)))

;; FIXGJB: I don't think this gets used right yet
(define animation-ms-delay 50)

;; Fluid, cartoon-like
;(set-animation! '#(-.01 0 .01 .03 .08 .18 .3 .45 .60 .75 .85 .90 .94 .97 .99 1.0))

;; Linear, mechanical
;(set-animation! '#(0.1 0.2 0.3 0.4 0.6 0.7 0.8 0.9 1.0))

;; Fluid, cartoon-like, overshoots target
;(set-animation! '#(-.01 0 .01 .03 .08 .18 .3 .45 .60 .75 .85 .90 .94 .97 .99 1.01 1.02 1.01 1))

(bind-key 'all "C-M-KP_7" (lambda () (animated-move-to 0 0)))
(bind-key 'all "C-M-KP_9" (lambda () (animated-move-to -1 0)))
(bind-key 'all "C-M-KP_1" (lambda () (animated-move-to 0 -1)))
(bind-key 'all "C-M-KP_3" (lambda () (animated-move-to -1 -1)))

(bind-key 'all "C-M-KP_8" (lambda () (animated-move-to 'x 0)))
(bind-key 'all "C-M-KP_6" (lambda () (animated-move-to -1 'y)))
(bind-key 'all "C-M-KP_2" (lambda () (animated-move-to 'x -1)))
(bind-key 'all "C-M-KP_4" (lambda () (animated-move-to 0 'y)))

;; FIXGJB: modifiers interface could be better... mimic off Emacs?
;; FIXGJB: keys should be first class
(bind-key 'all "C-M-S-7" (lambda () (send-button-press 1 0)))
(bind-key 'all "C-M-S-8" (lambda () (send-button-press 2 0)))
(bind-key 'all "C-M-S-9" (lambda () (send-button-press 3 0)))

;;(bind-key 'all "C-M-S-4" (lambda () (send-key-press "Return")))
(bind-key 'all "C-M-S-4" (lambda () (send-string "helloworld")))

;; This one is experimental-- sends only the buttonpress event, no buttonrelease
(bind-key 'all "C-M-S-0" (lambda () (send-button-press 2 0 (get-window) #t #f)))

(bind-key 'all "C-M-S-n" (lambda () (write (get-window)) (newline)))

;; Hyper-w
(bind-key 'all "H-w" (lambda () (write (get-window)) (newline)))
;; Alt-w
(bind-key 'all "A-w" (lambda () (display "alt-w\n")))

(define (sleep-ms ms)
  (select '() '() '() 0 (* 1000 ms)))

;; Does not work for arbitrary strings since, e.g,. ' ' needs
;; to be sent as "space"  FIXGJB: Do we have a char->keysym fn?
(define (send-string str)
  (let ((w (get-window))
	(i 0))
    (while (< i (length str))
	   (send-key-press (substring str i (+ 1 i)) w)
	   (set! i (+ 1 i)))))

;;; menu-item test cases
;(define sticky-menu-item (make-menu-item "Sticky" toggle-stick "C-S-F8" (make-image "mini-unkno.xpm") #f #f "sticky"))
;(define move-menu-item (make-menu-item "Move" interactive-move "C-S-F7" (make-image "mini-move.xpm") #f #f "move"))
;(define resize-menu-item (make-menu-item "Resize" interactive-resize "C-S-F8" (make-image "mini-resize.xpm") #f #f "resize"))
;(define a-menu (make-scwm-menu (list sticky-menu-item move-menu-item resize-menu-item)))


;;; Local Variables:
;;; eval: (load "scwm-buffer")
;;; End:
